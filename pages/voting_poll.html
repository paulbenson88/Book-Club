<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
<title>Voting Poll</title>
<link rel="icon" href="/favicon/favicon.ico" type="image/x-icon">
<link rel="preconnect" href="https://openlibrary.org" crossorigin>
<link rel="preconnect" href="https://covers.openlibrary.org" crossorigin>
<link rel="dns-prefetch" href="https://openlibrary.org">
<link rel="dns-prefetch" href="https://covers.openlibrary.org">
<!-- Early migration: ensure viewerIgnore flag is persisted before any snapshot handlers run -->
<script>
  try{
    if(sessionStorage.getItem('viewerIgnoreServerPolls') && !localStorage.getItem('viewerIgnoreServerPolls')){
      localStorage.setItem('viewerIgnoreServerPolls','1');
      console.log('[voting_poll] early migrated viewerIgnoreServerPolls from sessionStorage -> localStorage');
    }
    if(localStorage.getItem('viewerIgnoreServerPolls')){
  // Set a runtime global so later code (including snapshot handlers) can skip work immediately
  try{ window.__viewerIgnoreServerPolls = true; }catch(e){}
      try{ localStorage.removeItem('pollChoices'); }catch(e){}
      console.log('[voting_poll] early cleared local pollChoices because viewerIgnore is set');
  // Debug banner for diagnosing publish/show issues
  function updateDebugBanner(){
    try{
      var banner = document.getElementById('poll-debug-banner');
      if(!banner) return;
      var choices = localStorage.getItem('pollChoices');
      var publishedAt = localStorage.getItem('pollPublishedAt');
      var voterName = localStorage.getItem('voterName');
      banner.textContent = 'debug: pollChoices=' + (choices? 'SET':'') + ' publishedAt=' + (publishedAt? publishedAt:'') + ' voterName=' + (voterName||'');
    }catch(e){console.warn('[voting_poll] updateDebugBanner',e);}    
  }
    }
  }catch(e){ /* ignore */ }
</script>
  <!-- Diagnostics / Instrumentation (Issue #50) -->
  <script>
    (function(){
      try {
        if(!window.__pollDiag){
          window.__pollDiag = {
            log: function(evt, details){
              try{
                const ts = new Date().toISOString();
                const payload = { ts, evt, ...(details||{}) };
                let arr = [];
                try{ arr = JSON.parse(localStorage.getItem('__pollDiagLog')||'[]'); if(!Array.isArray(arr)) arr=[]; }catch(e){}
                arr.push(payload);
                if(arr.length>40) arr.splice(0, arr.length-40);
                try{ localStorage.setItem('__pollDiagLog', JSON.stringify(arr)); }catch(e){}
                console.log('[poll-diagnostic]', evt, payload);
              }catch(e){ /* swallow */ }
            },
            wrapRemove: function(key, reason){
              try {
                const before = localStorage.getItem(key);
                localStorage.removeItem(key);
                this.log('ls.remove', { key, hadValue: before!=null, reason });
              }catch(e){ this.log('ls.remove.error', { key, reason, err: String(e) }); }
            }
          };
        }
      }catch(e){ /* ignore */ }
    })();
  </script>
<!-- Guard utilities for preventing spurious clears -->
<script>
(function(){
  try{
    if(!window.__pollGuards){
      function computeSessionId(pcs, publishedAt){
        try{
          if(!Array.isArray(pcs) || pcs.length < 3) return null;
          const core = (publishedAt||'') + '::' + pcs.map(p=> (p.book||'').trim()).sort().join('|');
          // simple stable hash (FNV-1a like) then base36
          let h = 2166136261>>>0; for(let i=0;i<core.length;i++){ h ^= core.charCodeAt(i); h = Math.imul(h,16777619); }
          return 'ps_'+ (h>>>0).toString(36);
        }catch(e){ return null; }
      }
      function scheduleRestoreCheck(reason){
        try{
          if(window.__restoreTimer) clearTimeout(window.__restoreTimer);
          // Only schedule for empty-type clears (avoid winner / stale)
          if(!/empty|subscribe-empty|applySnapshot-empty/.test(reason)) return;
          const backupRaw = localStorage.getItem('__pollBackup');
          if(!backupRaw) return;
          window.__restoreTimer = setTimeout(()=>{
            try{
              const winner = localStorage.getItem('pollWinner');
              if(winner) return; // winner legit ends poll
              const pcsNow = JSON.parse(localStorage.getItem('pollChoices')||'null');
              if(Array.isArray(pcsNow) && pcsNow.length>=3) return; // already repopulated
              const backup = JSON.parse(backupRaw||'null');
              if(backup && Array.isArray(backup.pcs) && backup.pcs.length>=3){
                localStorage.setItem('pollChoices', JSON.stringify(backup.pcs));
                if(backup.publishedAt) localStorage.setItem('pollPublishedAt', backup.publishedAt);
                if(window.__pollDiag) window.__pollDiag.log('auto-restore', { fromReason: reason });
              }
            }catch(e){ window.__pollDiag && __pollDiag.log('auto-restore.error',{err:String(e)}); }
          }, 1400); // 1.4s confirmation window
        }catch(e){ }
      }
      function clearPoll(reason){
        try{
          const winner = localStorage.getItem('pollWinner');
          const pcs = JSON.parse(localStorage.getItem('pollChoices')||'null');
          const hadValid = Array.isArray(pcs) && pcs.length>=3;
          if(!winner && hadValid && /empty/.test(reason)){
            // strike logic: require 2 consecutive empties
            const strikes = (parseInt(localStorage.getItem('__emptyStrikes')||'0',10) || 0) + 1;
            localStorage.setItem('__emptyStrikes', String(strikes));
            if(strikes < 2){
              window.__pollDiag && __pollDiag.log('defer-clear', { reason, strikes });
              scheduleRestoreCheck(reason); // still schedule restore in case nothing arrives
              return false;
            }
          } else if(!/empty/.test(reason)) {
            // reset strike counter on non-empty reasons
            localStorage.setItem('__emptyStrikes','0');
          }
          // backup before destructive clear
          try{
            const backup = { pcs, votes: JSON.parse(localStorage.getItem('votes')||'{}'), publishedAt: localStorage.getItem('pollPublishedAt'), reason, at: Date.now() };
            localStorage.setItem('__pollBackup', JSON.stringify(backup));
          }catch(e){}
          if(window.__pollDiag) window.__pollDiag.log('clearPoll', { reason, hadValid });
          if(window.__pollDiag){
            __pollDiag.wrapRemove('pollChoices', reason);
            __pollDiag.wrapRemove('pollPublishedAt', reason);
          } else {
            localStorage.removeItem('pollChoices');
            localStorage.removeItem('pollPublishedAt');
          }
          localStorage.setItem('lastClearReason', reason);
          localStorage.setItem('lastClearAt', Date.now().toString());
          scheduleRestoreCheck(reason);
          return true;
        }catch(e){ window.__pollDiag && __pollDiag.log('clearPoll.error',{reason,err:String(e)}); }
      }
      window.__pollGuards = { computeSessionId, clearPoll };
    }
  }catch(e){ }
})();
</script>
<!-- Conditional staleness clearing: only purge obviously old or winner-completed data -->
<script>
  try {
    const publishedAt = localStorage.getItem('pollPublishedAt');
    const winner = localStorage.getItem('pollWinner');
    let isStale = false;
    if (publishedAt) {
      const ageMs = Date.now() - Date.parse(publishedAt);
      if (isNaN(ageMs) || ageMs > 1000*60*60*6) { // older than 6h
        isStale = true;
      }
    }
    if (winner) {
      // After a winner we shouldn't preserve old pollChoices/publishedAt for a new session
      isStale = true;
    }
    if (isStale) {
      try{ window.__pollDiag && __pollDiag.log('stale.clear.begin', { publishedAt, winner }); }catch(e){}
      try{ window.__pollDiag ? __pollDiag.wrapRemove('pollChoices','stale-clear') : localStorage.removeItem('pollChoices'); }catch(e){}
      try{ window.__pollDiag ? __pollDiag.wrapRemove('pollPublishedAt','stale-clear') : localStorage.removeItem('pollPublishedAt'); }catch(e){}
      console.log('[voting_poll] cleared stale poll cache');
    } else {
      console.log('[voting_poll] preserved existing poll cache for potential late join');
    }
  } catch(e) { }
</script>
<!-- Boot-time snapshot queue: queue first snapshot during initial rendering instead of discarding -->
<script>
  try {
    window.__viewerBlockApply = true;
    window.__queuedSnapshot = null;
    console.log('[voting_poll] boot block set (queue mode)');
    setTimeout(()=>{
      try {
        window.__viewerBlockApply = false;
        console.log('[voting_poll] boot block cleared');
        if(window.__queuedSnapshot){
          console.log('[voting_poll] applying queued snapshot now');
          try{ window.__applyPollSnapshot(window.__queuedSnapshot); }catch(e){ console.warn('[voting_poll] queued snapshot apply failed', e); }
          window.__queuedSnapshot = null;
        }
      } catch(e){}
    }, 600);
  } catch(e){}
</script>
  <!-- Firebase compat SDK (CDN). Define window.FIREBASE_CONFIG separately to enable cross-device sync. -->
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-auth-compat.js"></script>
  <script src="../js/firebase-config.js"></script>
  <script src="../js/firebase-sync.js"></script>
  <style>
    .shadow-sm { box-shadow: 0 1px 2px rgba(0,0,0,0.1); }
    /* transition helpers */
    .fade-in { animation: fadeIn 420ms cubic-bezier(.2,.8,.2,1) both; }
    .fade-out { animation: fadeOut 300ms cubic-bezier(.2,.8,.2,1) both; }
    @keyframes fadeIn { from { opacity: 0; transform: translateY(8px); } to { opacity: 1; transform: none; } }
    @keyframes fadeOut { from { opacity: 1; transform: none; } to { opacity: 0; transform: translateY(-8px); } }
  /* Prompt card styling and transitions */
  #poll-ready { transition: opacity 320ms ease, transform 320ms ease; }
  .prompt-card { padding:12px; }
  .prompt-actions { display:flex; gap:10px; margin-top:8px; }
  .prompt-actions .btn { min-width:160px; }
  /* Match site primary CTA look (fallback if site CSS not loaded) */
  .btn.cta-primary, .btn-primary.cta-primary { background:#0d6efd; color:#fff; border:1px solid rgba(0,0,0,0.08); }
  .btn-outline-secondary { border:1px solid #ced4da; background:transparent; color:#333; }
  /* Waiting view styles */
  .wait-box { display:flex; flex-direction:column; align-items:center; gap:12px; padding:12px; }
  .wait-dog { width:220px; max-width:90%; border-radius:12px; box-shadow:0 6px 18px rgba(0,0,0,0.12); }
  .wait-text { font-size:1.05em; color:#333; max-width:380px; text-align:center; }
  .wait-sub { color:#666; font-size:0.95em; }
  .spinner { width:48px; height:48px; border:5px solid #eee; border-top-color:#007bff; border-radius:50%; animation:spin 1s linear infinite; }
  @keyframes spin { to { transform:rotate(360deg); } }
  .dog-bob { animation: bob 2s ease-in-out infinite; }
  @keyframes bob { 0%{transform:translateY(0)}50%{transform:translateY(-6px)}100%{transform:translateY(0)} }
  /* Poll updates are published by admin; no background polling on this page */
  /* small helpers for this page */
  .flex-gap { display:flex; gap:8px; flex-wrap:wrap; }
  .poll-reset-banner { display:none; margin-top:12px; padding:8px; border-radius:6px; background:#fff3cd; color:#856404; border:1px solid #ffeeba; font-size:0.95em; }
  /* Poll responsive fixes: ensure items don't overlap and vote control stays left */
  .poll-item { width:100%; box-sizing:border-box; display:flex; align-items:center; gap:12px; margin:12px 0; padding:12px; border:1px solid #e5e5e5; border-radius:8px; background:#fff; }
  .poll-content { flex:1 1 auto; min-width:0; text-align:left; }
  .vote-container { flex:0 0 86px; display:flex; align-items:center; justify-content:center; padding:8px; border-radius:8px; background:#f6f6f6; border:1px solid #e6e6e6; }
  .vote-container input[type="checkbox"] { transform: scale(1.15); margin-right:8px; }
  .vote-label.bold { font-weight:700; }
  @media (max-width:600px){
    .poll-item { gap:10px; }
    .vote-container { flex:0 0 72px; }
    .vote-container input[type="checkbox"] { transform: scale(1.05); }
    .wait-dog { width:160px; }
  }
  /* Dim and disable poll area until voter submits name */
  .poll-needs-name { opacity: 0.6; pointer-events: none; }
  /* Center the poll title (scoped to this page) */
  .poll-title { text-align:center; }
  /* Winner cover */
  .winner-cover-wrap { display:flex; justify-content:center; margin-top:12px; }
  .winner-cover { width: 180px; height: 270px; object-fit: cover; border-radius: 6px; box-shadow: 0 6px 18px rgba(0,0,0,0.15); opacity: 0; transition: opacity 280ms ease; background: #f4f4f4; }
  .winner-cover.ready { opacity: 1; }
  .winner-cover--placeholder { display:flex; align-items:center; justify-content:center; background:#f4f4f4; color:#222; font-weight:800; text-align:center; padding:12px; border:1px dashed #ddd; overflow:hidden; letter-spacing:0.5px; }
  .winner-cover--placeholder .ph { width:100%; }
  .winner-cover--placeholder .ph-line { display:block; }
  .winner-cover--placeholder .ph-line:first-child { margin-bottom:8px; }
  .winner-cover--placeholder .ph-title { font-size: clamp(20px, 5.2vw, 34px); line-height: 1.05; }
  @media (min-width: 768px) { .winner-cover--placeholder .ph-title { font-size: 32px; } }
  </style>
  <link rel="stylesheet" href="../css/styles.css">
  <style>
    /* Overrides after main stylesheet to keep vote control left on mobile */
    @media (max-width:600px) {
      .poll-item { flex-direction: row !important; align-items: center !important; gap: 8px !important; }
      .vote-container { min-width:56px !important; flex: 0 0 56px !important; justify-content: center !important; padding:6px !important; }
      .vote-container input[type="checkbox"] { transform: scale(0.95) !important; }
      .vote-label { display:block; font-size:0.9rem; margin-top:4px; }
      .poll-content label { font-size:1rem; }
      /* Prevent poll cards from collapsing or overlapping */
      #poll-options { overflow: visible; }
    }
  /* Make the name input responsive so it can't overflow the card */
  #nameInput { width:100% !important; max-width:100% !important; box-sizing:border-box !important; display:block; }
  /* Add extra breathing room between the name input and action buttons */
  .name-actions { margin-top:12px !important; gap:12px !important; }
  /* Confetti overlay */
  .confetti-canvas { position: fixed; inset: 0; width: 100vw; height: 100vh; pointer-events: none; z-index: 9999; }
  /* Total votes label under the voters list */
  .vote-total { color:#555; font-size:0.85rem; margin-top: 2px; }
  /* Prominent name entry panel */
  .name-panel { background:#fff; border:1px solid #e6e6e6; border-radius:10px; padding:12px; box-shadow:0 4px 14px rgba(0,0,0,0.06); max-width:560px; margin:0 auto; }
  .name-title { font-weight:600; margin-bottom:6px; }
  .name-hint { color:#666; font-size:0.9rem; margin-bottom:8px; }
  #nameInput.is-invalid { border-color:#dc3545; box-shadow: 0 0 0 .2rem rgba(220,53,69,.075); }
  .invalid-feedback { color:#dc3545; font-size:0.85rem; margin-top:6px; display:none; }
  .invalid-feedback.show { display:block; }
  @media(max-width:600px){ .name-panel{ padding:10px; } .name-actions .btn{ width:100%; } }
  </style>
</head>

<body>
  <nav class="site-nav">
    <a href="../index.html" class="main-page-btn">🏠 Main Page</a>
  </nav>

  <div class="container">
    <div class="card">
      <div class="card-body">
        <!-- Poll updates are published by admin; viewers will react to storage events -->
  <h1 class="card-title poll-title">📚 Voting Poll</h1>

  <div id="poll-status" class="mb-3"></div>
  <div id="poll-loading" class="d-none"></div>
  <div id="poll-ready" class="mb-3 d-none"></div>

  <!-- Removed empty .section wrapper that caused a small gray box (fixes #30) -->
  <!-- Name input so voters can identify themselves and enable voting (hidden until poll is published) -->
  <div id="name-flow" class="mb-3" style="display:none;">
    <div class="name-panel">
      <div class="name-title">Enter your name to join the vote</div>
      <div class="name-hint">We use your name so your selections count. You can edit it later.</div>
      <input type="text" id="nameInput" placeholder="Your name" aria-describedby="nameHint nameError" />
      <div id="nameError" class="invalid-feedback" role="alert">Please enter your name.</div>
      <div id="nameHint" class="visually-hidden">Submitting your name enables voting.</div>
      <div class="mb-3 flex-gap name-actions" style="display:none;">
        <button id="submitNameBtn" class="btn cta-primary">Submit Name</button>
        <button id="editNameBtn" class="main-page-btn" style="display:none;">Edit Name</button>
      </div>
    </div>
  </div>
  <div id="poll-reset-banner" class="poll-reset-banner"></div>
  <!-- Poll UI (legacy) -->
  <div id="poll-options" style="display:none;"></div>
  <!-- Runoff UI (shown when a tiebreaker runoff is active) -->
  <div id="runoff-options" style="display:none;"></div>

  <!-- Selected Books section removed -->
  <script>
// Attach Firebase listener if config + SDK available and mirror into localStorage for this viewer
(function(){
  try{
    // Expect FIREBASE_CONFIG to be defined globally (provide separately)
    // Load Firebase SDK if not already loaded (viewer previously avoided it)
  }catch(e){}
})();
// Helper to get normalized pollChoices from localStorage
function getPollChoices() {
  let pollChoicesRaw = JSON.parse(localStorage.getItem('pollChoices') || '[]') || [];
  // Normalize possible legacy shapes and filter out empty titles
  let pollChoices = [];
  if (Array.isArray(pollChoicesRaw) && pollChoicesRaw.length){
    pollChoices = pollChoicesRaw.map(item => {
      if (!item) return null;
      const book = item.book || item.display || item.title || item[0] || '';
      const name = item.name || item.suggestedBy || item[1] || '';
      return { book: String(book).trim(), name: String(name).trim() };
    }).filter(x => x && x.book && x.book.length > 0);
  }
  return pollChoices;
}

// Confetti gating: only celebrate on live announcements, not on initial load
window.__celebrateWinnerNext = false;
window.__fbStateInited = false;
window.__lastWinnerBook = null;

// Helpers for safe DOM keys
function slugifyId(text){
  try{ return ('voters-'+String(text||'')).toLowerCase().replace(/[^a-z0-9]+/g,'-').replace(/^-+|-+$/g,''); }catch(e){ return 'voters-unknown'; }
}
function htmlEscape(s){ try{ return String(s||'').replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;'); }catch(e){ return String(s||''); } }

// Unified snapshot apply function so we can queue during boot
function __applyPollSnapshot(state){
  try{
    if(!state) return;
    // Respect ignore flag
    if(localStorage.getItem('viewerIgnoreServerPolls') || sessionStorage.getItem('viewerIgnoreServerPolls')){
      try{ debugBanner && (debugBanner.textContent = 'Viewer is ignoring server polls'); }catch(e){}
      return;
    }
    // Winner path
    if(state && state.winner && state.winner.book){
      const book = state.winner.book;
      const isNewWinner = window.__fbStateInited && window.__lastWinnerBook !== book;
      window.__celebrateWinnerNext = !!isNewWinner;
      window.__lastWinnerBook = book;
      try{ localStorage.setItem('pollWinner', JSON.stringify(state.winner)); }catch(e){}
      // Clear poll-only keys (don't clear winner)
  try{ window.__pollDiag ? __pollDiag.wrapRemove('pollChoices','applySnapshot-winner') : localStorage.removeItem('pollChoices'); }catch(e){}
  try{ window.__pollDiag ? __pollDiag.wrapRemove('pollPublishedAt','applySnapshot-winner') : localStorage.removeItem('pollPublishedAt'); }catch(e){}
      try{ renderWinner(book); }catch(e){}
      window.__fbStateInited = true;
      return;
    }
    // Runoff path
    if(state && state.runoff && state.runoff.active){
      const pcs = Array.isArray(state.runoff.choices) ? state.runoff.choices : [];
      try{ renderRunoff(pcs); }catch(e){}
      window.__fbStateInited = true;
      return;
    }
    // Normal poll
    const pcs = Array.isArray(state && state.pollChoices) ? state.pollChoices : [];
    const publishedAt = state && state.pollPublishedAt ? String(state.pollPublishedAt) : null;
    if(publishedAt && pcs.length >= 3){
      try{ localStorage.setItem('pollChoices', JSON.stringify(pcs)); }catch(e){}
      try{ localStorage.setItem('pollPublishedAt', publishedAt); }catch(e){}
      try{ const sid = window.__pollGuards && __pollGuards.computeSessionId(pcs, publishedAt); if(sid) localStorage.setItem('pollSessionId', sid); }catch(e){}
      try{ renderPollOrWaiting(); }catch(e){}
    } else {
      // Consider this a cleared poll (guarded)
      try{ if(window.__pollGuards){ __pollGuards.clearPoll('applySnapshot-empty'); } else { window.__pollDiag ? __pollDiag.wrapRemove('pollChoices','applySnapshot-empty') : localStorage.removeItem('pollChoices'); window.__pollDiag ? __pollDiag.wrapRemove('pollPublishedAt','applySnapshot-empty') : localStorage.removeItem('pollPublishedAt'); } }catch(e){}
      try{ renderPollOrWaiting(); }catch(e){}
    }
    window.__fbStateInited = true;
  }catch(e){ console.warn('[voting_poll] snapshot apply failed', e); }
}
(function(){
  try{
    if(window.fbSyncAvailable && typeof window.fbSubscribe === 'function'){
      window.fbSubscribe(function(state){
        try{
          console.log('[voting_poll] snapshot received', state);
          if(window.__viewerBlockApply){
            window.__queuedSnapshot = state;
            console.log('[voting_poll] snapshot queued (boot block)');
            return;
          }
          __applyPollSnapshot(state);
        }catch(e){ console.warn('[voting_poll] fbSubscribe handler error', e); }
      });
      console.log('[voting_poll] Firebase subscription active');
    } else {
      console.log('[voting_poll] Firebase not configured; viewer falls back to localStorage/storage events only');
    }
  }catch(e){ console.warn('[voting_poll] fb subscribe setup error', e); }
})();
// Helper to get normalized pollChoices from localStorage
function getPollChoices() {
  let pollChoicesRaw = JSON.parse(localStorage.getItem('pollChoices') || '[]') || [];
  // Normalize possible legacy shapes and filter out empty titles
  let pollChoices = [];
  if (Array.isArray(pollChoicesRaw) && pollChoicesRaw.length){
    pollChoices = pollChoicesRaw.map(item => {
      if (!item) return null;
      const book = item.book || item.display || item.title || item[0] || '';
      const name = item.name || item.suggestedBy || item[1] || '';
      return { book: String(book).trim(), name: String(name).trim() };
    }).filter(x => x && x.book && x.book.length > 0);
  }
  return pollChoices;
}

// Helpers for safe DOM keys
function slugifyId(text){
  try{ return ('voters-'+String(text||'')).toLowerCase().replace(/[^a-z0-9]+/g,'-').replace(/^-+|-+$/g,''); }catch(e){ return 'voters-unknown'; }
}
function htmlEscape(s){ try{ return String(s||'').replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;'); }catch(e){ return String(s||''); } }

(function(){
  try{
    if(window.fbSyncAvailable && typeof window.fbSubscribe === 'function'){
      window.fbSubscribe(function(state){
        try{
          // Respect viewer ignore flag: don't apply remote state
          if(localStorage.getItem('viewerIgnoreServerPolls') || sessionStorage.getItem('viewerIgnoreServerPolls')){
            try{ debugBanner && (debugBanner.textContent = 'Viewer is ignoring server polls'); }catch(e){}
            return;
          }
          // Apply winner first; if set, it should override any active runoff UI
          if(state && state.winner && state.winner.book){
            const book = state.winner.book;
            // Celebrate only if this winner is newly observed after initial snapshot
            const isNewWinner = window.__fbStateInited && window.__lastWinnerBook !== book;
            window.__celebrateWinnerNext = !!isNewWinner;
            window.__lastWinnerBook = book;
            try{ localStorage.setItem('pollWinner', JSON.stringify(state.winner)); }catch(e){}
            try{ window.__pollDiag ? __pollDiag.wrapRemove('pollChoices','subscribe-winner') : localStorage.removeItem('pollChoices'); }catch(e){}
            try{ window.__pollDiag ? __pollDiag.wrapRemove('pollPublishedAt','subscribe-winner') : localStorage.removeItem('pollPublishedAt'); }catch(e){}
            try{ renderWinner(book); }catch(e){}
            // Stop any runoff listeners when a winner is announced
            try{ if(window.__unsubRunoffVotes){ window.__unsubRunoffVotes(); window.__unsubRunoffVotes = null; } }catch(e){}
            window.__fbStateInited = true;
            return;
          }
          // If a tiebreaker runoff is active, render it and return
          if(state && state.runoff && state.runoff.active){
            const pcs = Array.isArray(state.runoff.choices) ? state.runoff.choices : [];
            try{ renderRunoff(pcs); }catch(e){}
            window.__fbStateInited = true;
            return;
          }
          // No winner — apply poll state
          const pcs = Array.isArray(state && state.pollChoices) ? state.pollChoices : [];
          // Ensure any runoff listener is removed when showing normal poll
          try{ if(window.__unsubRunoffVotes){ window.__unsubRunoffVotes(); window.__unsubRunoffVotes = null; } }catch(e){}
          const publishedAt = state && state.pollPublishedAt ? String(state.pollPublishedAt) : null;
          if(publishedAt && pcs.length >= 3){
            try{ localStorage.setItem('pollChoices', JSON.stringify(pcs)); }catch(e){}
            try{ localStorage.setItem('pollPublishedAt', publishedAt); }catch(e){}
            try{ const sid = window.__pollGuards && __pollGuards.computeSessionId(pcs, publishedAt); if(sid) localStorage.setItem('pollSessionId', sid); }catch(e){}
            try{ renderPollOrWaiting(); }catch(e){}
          } else {
            // Clear poll locally (guarded)
            try{ if(window.__pollGuards){ __pollGuards.clearPoll('subscribe-empty'); } else { window.__pollDiag ? __pollDiag.wrapRemove('pollChoices','subscribe-empty') : localStorage.removeItem('pollChoices'); window.__pollDiag ? __pollDiag.wrapRemove('pollPublishedAt','subscribe-empty') : localStorage.removeItem('pollPublishedAt'); } }catch(e){}
            try{ renderPollOrWaiting(); }catch(e){}
          }
          window.__fbStateInited = true;
        }catch(e){ console.warn('[voting_poll] fbSubscribe apply failed', e); }
      });
      try{ console.log('[voting_poll] Firebase subscription active'); }catch(e){}
    } else {
      try{ console.log('[voting_poll] Firebase not configured; viewer falls back to localStorage/storage events only'); }catch(e){}
    }
  }catch(e){ console.warn('[voting_poll] fb subscribe setup error', e); }
})();
// (duplicate getPollChoices removed)

  let votes = JSON.parse(localStorage.getItem("votes")) || {}; // Load votes
  const pollOptions = document.getElementById("poll-options");
  function setPollOptionsVisible(visible){ try{ if(!pollOptions) return; pollOptions.style.display = visible ? '' : 'none'; }catch(e){} }
  let pollVisible = false;
  const nameInput = document.getElementById("nameInput");
  const submitNameBtn = document.getElementById("submitNameBtn");
  const editNameBtn = document.getElementById("editNameBtn");
  let voterName = "";
  let viewerHasEnteredNameFlow = false; // becomes true after user clicks "Enter your name" or has saved name
  // Clear/Accept controls removed from finished viewer UI (defensive behavior enforced instead)
  // small debug banner to show raw pollChoices (helpful during troubleshooting)
  let debugBanner = document.getElementById('poll-debug-banner');
  if(!debugBanner){
    try{
      debugBanner = document.createElement('div');
      debugBanner.style.marginTop='8px'; debugBanner.style.fontSize='0.9rem'; debugBanner.style.color='#666';
      debugBanner.id='poll-debug-banner';
      const _ps = document.getElementById('poll-status');
      if(_ps) _ps.appendChild(debugBanner);
    }catch(e){ /* ignore if DOM not ready */ }
  }

  // Early migration: if an older session set the sessionStorage ignore flag, persist it to localStorage
  try{
    if(sessionStorage.getItem('viewerIgnoreServerPolls') && !localStorage.getItem('viewerIgnoreServerPolls')){
      try{ localStorage.setItem('viewerIgnoreServerPolls','1'); console.log('[voting_poll] migrated viewerIgnoreServerPolls from sessionStorage -> localStorage (early)'); }catch(e){}
    }
  }catch(e){}

  // Helper to determine if the viewer is ignoring server polls (accept either old session flag or new persistent local flag)
  function viewerIsIgnoring(){ try{ return !!(localStorage.getItem('viewerIgnoreServerPolls') || sessionStorage.getItem('viewerIgnoreServerPolls')); }catch(e){ return false; } }

  function setNameControlsVisible(visible){
    try{
      const flow = document.getElementById('name-flow');
      const na = document.querySelector('.name-actions');
      if(flow) flow.style.display = visible ? '' : 'none';
      if(na) na.style.display = visible ? 'flex' : 'none';
    }catch(e){}
  }
  // Initialize name UI based on saved state; used even when poll hasn't been published yet
  function initNameControlsFromSaved(){
    try{
      setNameControlsVisible(true);
      const saved = localStorage.getItem('voterName');
      if(saved && saved.length){
        voterName = saved;
        if(nameInput){ nameInput.value = saved; nameInput.disabled = true; }
        if(submitNameBtn) submitNameBtn.style.display='none';
        if(editNameBtn) editNameBtn.style.display='inline-block';
        // If poll exists later, make sure it's not dimmed
        try{ if(pollOptions) pollOptions.classList.remove('poll-needs-name'); }catch(e){}
        // Treat saved name as already entered so we skip the prompt when poll is published
        viewerHasEnteredNameFlow = true;
      } else {
        // No saved name — allow entering now (ahead of poll publish)
        if(nameInput){ nameInput.disabled = false; }
        if(submitNameBtn) submitNameBtn.style.display='inline-block';
        if(editNameBtn) editNameBtn.style.display='none';
        // Keep viewerHasEnteredNameFlow as-is (false) until they submit
      }
    }catch(e){}
  }
  // Hide just the name entry/edit UI after a winner is announced (issue #31)
  function hideNameControlsAfterWinner(){
    try{
      const flow = document.getElementById('name-flow');
      const ni = document.getElementById('nameInput');
      const submitBtn = document.getElementById('submitNameBtn');
      const editBtn = document.getElementById('editNameBtn');
      if(flow) flow.style.display = 'none';
      if(ni){ ni.blur(); }
      if(submitBtn) submitBtn.style.display='none';
      if(editBtn) editBtn.style.display='none';
    }catch(e){}
  }

  function showPollEntryPrompt(){
    try{
      const p = document.getElementById('poll-ready');
      console.log('[voting_poll] showPollEntryPrompt called, element?', !!p);
      if(!p) return;
      // Build content depending on whether a saved voterName exists
      const saved = localStorage.getItem('voterName');
      if(saved && saved.trim().length){
        p.innerHTML = `
          <div class="card shadow-sm prompt-card">
            <div style="font-weight:600; margin-bottom:8px;">The poll is ready!</div>
            <div class="small text-muted" style="margin-bottom:10px;">Continue as <strong>${String(saved).replace(/</g,'&lt;')}</strong> or use a different name.</div>
            <div class="prompt-actions"><button id="continueAsSavedBtn" class="btn cta-primary">Continue as ${String(saved).replace(/</g,'&lt;')}</button><button id="enterNameBtn" class="btn btn-outline-secondary">Use a different name</button></div>
          </div>`;
        // ensure visible and hide any waiting UI so the prompt replaces it
        p.classList.remove('d-none'); p.style.display=''; p.style.visibility='visible'; p.style.opacity=0; p.style.transform='translateY(6px)';
        try{ const statusEl = document.getElementById('poll-status'); if(statusEl){ statusEl.innerHTML = ''; statusEl.style.display = 'none'; } }catch(e){}
        // animate in
        requestAnimationFrame(()=>{ p.style.transition='opacity 320ms ease, transform 320ms ease'; p.style.opacity=1; p.style.transform='translateY(0)'; });
        // Wire buttons after render
        setTimeout(()=>{
          try{ const c = document.getElementById('continueAsSavedBtn'); if(c) c.addEventListener('click', acceptSavedName); }catch(e){}
          try{ const ebtn = document.getElementById('enterNameBtn'); if(ebtn) ebtn.addEventListener('click', beginNameFlow); }catch(e){}
        },40);
      } else {
        p.innerHTML = `
          <div class="card shadow-sm prompt-card">
            <div style="font-weight:600; margin-bottom:8px;">The poll is ready!</div>
            <div class="small text-muted" style="margin-bottom:10px;">Enter your name to begin voting.</div>
            <div class="prompt-actions"><button id="enterNameBtn" class="btn cta-primary">Enter your name to begin</button></div>
          </div>`;
        p.classList.remove('d-none'); p.style.display=''; p.style.visibility='visible'; p.style.opacity=0; p.style.transform='translateY(6px)';
        try{ const statusEl = document.getElementById('poll-status'); if(statusEl){ statusEl.innerHTML = ''; statusEl.style.display = 'none'; } }catch(e){}
        requestAnimationFrame(()=>{ p.style.transition='opacity 320ms ease, transform 320ms ease'; p.style.opacity=1; p.style.transform='translateY(0)'; });
        setTimeout(()=>{ try{ const enterBtn = document.getElementById('enterNameBtn'); if(enterBtn) enterBtn.addEventListener('click', beginNameFlow); }catch(e){} },40);
      }
      try{ updateDebugBanner(); }catch(e){}
    }catch(e){ console.warn('[voting_poll] showPollEntryPrompt error', e); }
  }
  function hidePollEntryPrompt(){ try{ const p = document.getElementById('poll-ready'); console.log('[voting_poll] hidePollEntryPrompt called, element?', !!p); if(!p) return; // animate out then hide
    try{ p.style.transition='opacity 220ms ease, transform 220ms ease'; p.style.opacity=0; p.style.transform='translateY(-6px)'; }catch(e){}
    setTimeout(()=>{ try{ p.classList.add('d-none'); p.style.display = 'none'; p.style.visibility = 'hidden'; try{ restoreWaitingArea(); }catch(e){} }catch(e){} }, 260);
    try{ updateDebugBanner(); }catch(e){} }catch(e){ console.warn('[voting_poll] hidePollEntryPrompt error', e); } }

  // When hiding the prompt, restore the status area so waiting messages can appear later
  function restoreWaitingArea(){ try{ const statusEl = document.getElementById('poll-status'); if(statusEl){ statusEl.style.display = ''; } }catch(e){} }

  function beginNameFlow(){ try{ console.log('[voting_poll] beginNameFlow called'); viewerHasEnteredNameFlow = true; // ensure prompt hidden via both class and inline style
      // animate prompt out then show name controls
      try{ const p = document.getElementById('poll-ready'); if(p){ p.style.transition='opacity 220ms ease, transform 220ms ease'; p.style.opacity = 0; p.style.transform='translateY(-6px)'; } }catch(e){}
      setTimeout(()=>{
        try{ hidePollEntryPrompt(); setNameControlsVisible(true); if(nameInput){ nameInput.style.display='block'; nameInput.focus(); } }catch(e){}
        // dim the poll area until name submitted
        try{ if(pollOptions) pollOptions.classList.add('poll-needs-name'); }catch(e){}
        // render after showing controls so checkboxes are wired
        try{ renderPollOrWaiting(); }catch(e){}
        try{ updateDebugBanner(); }catch(e){}
      }, 260);
    }catch(e){ console.warn('[voting_poll] beginNameFlow error', e); } }

  function acceptSavedName(){
    try{
      const saved = localStorage.getItem('voterName');
      if(!saved) return beginNameFlow();
      console.log('[voting_poll] acceptSavedName called, saved=', saved);
      viewerHasEnteredNameFlow = true;
      // animate prompt out then apply saved name state
      try{ const p = document.getElementById('poll-ready'); if(p){ p.style.transition='opacity 220ms ease, transform 220ms ease'; p.style.opacity=0; p.style.transform='translateY(-6px)'; } }catch(e){}
      setTimeout(()=>{
        try{
          // Populate UI with saved name and mark as submitted
          voterName = saved;
          if(nameInput){ nameInput.value = saved; nameInput.disabled = true; }
          try{ submitNameBtn.style.display = 'none'; editNameBtn.style.display = 'inline-block'; }catch(e){}
          try{ if(pollOptions) pollOptions.classList.remove('poll-needs-name'); }catch(e){}
          hidePollEntryPrompt(); setNameControlsVisible(true);
          try{ renderPollOrWaiting(); }catch(e){}
          try{ updateDebugBanner(); }catch(e){}
        }catch(e){ console.warn('[voting_poll] acceptSavedName inner error', e); }
      }, 260);
    }catch(e){ console.warn('[voting_poll] acceptSavedName error', e); }
  }

  // viewerHasAccepted removed; finished viewer will not show Accept/Clear controls

  // Display poll options or waiting UI
  function renderPollOrWaiting() {
    // If viewer has chosen to ignore server polls (session or persisted), do not render any stored pollChoices
    try{
        const _ign = !!(localStorage.getItem('viewerIgnoreServerPolls') || sessionStorage.getItem('viewerIgnoreServerPolls'));
        console.log('[voting_poll] viewerIsIgnoring?', _ign, 'local:', localStorage.getItem('viewerIgnoreServerPolls'), 'session:', sessionStorage.getItem('viewerIgnoreServerPolls'));
        if(_ign){
          try{ debugBanner.textContent = 'Viewer is ignoring server polls'; }catch(e){}
          setPollOptionsVisible(false);
    showWaitingMessage('Wait until the lead has randomly chosen all three books with the slot machine.');
    // Allow entering name ahead of time even while waiting/ignoring
  try{ initNameControlsFromSaved(); }catch(e){}
      return;
        }
    // Defensive: finished viewers must not render persisted pollChoices; allow render to continue only if pollChoices are present and were written in this session
    // (We already removed persisted pollChoices on load.)
    }catch(e){}
    const pollChoices = getPollChoices();
    // Only render a poll if admin explicitly published it (pollPublishedAt set)
    try{ 
      const publishedAt = localStorage.getItem('pollPublishedAt'); 
      const savedName = (localStorage.getItem('voterName')||'').trim();
      if(!publishedAt){ 
        // Poll not started yet
        if(!savedName){
          // Show ONLY name UI (no Merc waiting yet)
          setPollOptionsVisible(false);
          try{ const status = document.getElementById('poll-status'); if(status) status.innerHTML=''; }catch(e){}
          try{ setNameControlsVisible(true); if(nameInput){ nameInput.disabled=false; nameInput.focus(); } if(submitNameBtn){ submitNameBtn.style.display='inline-block'; } if(editNameBtn){ editNameBtn.style.display='none'; } }catch(e){}
          return; 
        } else {
          // Name submitted but poll not yet published: now show Merc waiting UI
          setPollOptionsVisible(false);
          showWaitingMessage('Wait until the lead has randomly chosen all three books with the slot machine.');
          return;
        }
      } 
    }catch(e){}
    // If the poll is published, require a submitted name before showing any poll UI
    try{
      const saved = (localStorage.getItem('voterName')||'').trim();
      const publishedAtDebug = localStorage.getItem('pollPublishedAt');
      console.log('[voting_poll] name gating:', 'savedName=', saved ? 'yes' : 'no', 'publishedAt=', publishedAtDebug);
      if(!saved){
        // Force name entry view only
        try{ hidePollEntryPrompt(); }catch(e){}
        try{ setPollOptionsVisible(false); }catch(e){}
        try{ const ro = document.getElementById('runoff-options'); if(ro){ ro.style.display='none'; ro.innerHTML=''; } }catch(e){}
        try{ const status = document.getElementById('poll-status'); if(status){ status.innerHTML=''; } }catch(e){}
        try{ setNameControlsVisible(true); if(nameInput){ nameInput.disabled=false; nameInput.focus(); } if(submitNameBtn){ submitNameBtn.style.display='inline-block'; } if(editNameBtn){ editNameBtn.style.display='none'; } }catch(e){}
        // Ensure the poll area remains dimmed/inactive until name is submitted
        try{ if(pollOptions) pollOptions.classList.add('poll-needs-name'); }catch(e){}
        return;
      } else {
        // We have a saved name: hide any prompt and proceed
        try{ hidePollEntryPrompt(); }catch(e){}
      }
    }catch(e){}
  // (name already required above)
    console.log('[voting_poll] renderPollOrWaiting pollChoices:', pollChoices);
    if (!Array.isArray(pollChoices) || pollChoices.length < 3) {
      // Defensive: if stored pollChoices are present but malformed, clear them so viewers show waiting UI
      try{ const raw = JSON.parse(localStorage.getItem('pollChoices') || 'null'); if(Array.isArray(raw) && raw.length > 0 && (!Array.isArray(pollChoices) || pollChoices.length < 3)){ localStorage.removeItem('pollChoices'); } }catch(e){}
      setPollOptionsVisible(false);
      showWaitingMessage('Wait until the lead has randomly chosen all three books with the slot machine.');
      return;
    }
    // Hide waiting UI when showing poll
    const status = document.getElementById('poll-status');
    if(status) status.innerHTML = '';
    pollOptions.innerHTML = "";
    setPollOptionsVisible(true);
    // Reveal name controls when poll is visible
    try{ setNameControlsVisible(true); }catch(e){}
    // Restore voterName from session if present (only when poll is visible)
      // Restore voterName from localStorage if present (only when poll is visible)
      try{
        const saved = localStorage.getItem('voterName');
        if(saved && saved.length){
          voterName = saved;
          if(nameInput) nameInput.value = saved;
          try{ nameInput.disabled = true; submitNameBtn.style.display='none'; editNameBtn.style.display='inline-block'; }catch(e){}
          try{ if(pollOptions) pollOptions.classList.remove('poll-needs-name'); }catch(e){}
        } else {
          // No name present: autofocus the name input and dim the poll area
          try{ if(nameInput) nameInput.focus(); if(pollOptions) pollOptions.classList.add('poll-needs-name'); }catch(e){}
        }
      }catch(e){}
    pollChoices.forEach((choice, index) => {
      const option = document.createElement("div");
      option.className = "poll-item";
      const _book = String(choice.book||'');
      const _name = String(choice.name||'');
      const votersId = slugifyId(_book);
      option.innerHTML = `
        <div class="vote-container">
          <input type="checkbox" id="choice${index}" name="poll" value="${htmlEscape(_book)}">
          <label for="choice${index}" class="vote-label">Vote</label>
        </div>
        <div class="poll-content">
          <label for="choice${index}">${htmlEscape(_book)}</label>
          <div class="suggested-by">Suggested by ${htmlEscape(_name)}</div>
          <div class="voters" id="${votersId}" data-book="${htmlEscape(_book)}">Voted by: ${getVoters(_book)}</div>
          <div class="vote-total" data-book="${htmlEscape(_book)}">Total Votes: ${(Array.isArray(votes[_book])?votes[_book].length:0)}</div>
        </div>
      `;
      pollOptions.appendChild(option);
      // Wire up checkbox state according to current voterName and votes
      const checkbox = option.querySelector("input[type='checkbox']");
      const voteLabel = option.querySelector('.vote-label');
      checkbox.disabled = !voterName;
      try{ checkbox.checked = isUserVoted(choice.book); }catch(e){}
      if(voterName){ voteLabel.classList.add('bold'); } else { voteLabel.classList.remove('bold'); }
      checkbox.addEventListener("change", () => toggleVote(choice.book));
      // Initialize total votes label from current votes map
      try{ updateVoteCount(choice.book); }catch(e){}
    });
    // Add multi-select caption at top (not shown in runoff or winner states)
    try {
      const existingCaption = document.getElementById('multi-choice-caption');
      if(existingCaption) existingCaption.remove();
      const winner = localStorage.getItem('pollWinner');
      const runoffActive = !!document.getElementById('runoff-options') && document.getElementById('runoff-options').style.display !== 'none';
      if(!winner && !runoffActive){
        const cap = document.createElement('div');
        cap.id = 'multi-choice-caption';
        cap.className = 'text-muted small';
  cap.style.fontSize = '0.75rem';
  cap.style.marginTop = '12px'; // a bit more breathing room now that border removed
  cap.style.marginBottom = '6px';
  cap.style.paddingTop = '0';
  cap.style.fontWeight = '400';
        cap.textContent = 'Multiple choices allowed';
        // Insert before first poll item (top of list)
        if(pollOptions.firstChild){
          pollOptions.insertBefore(cap, pollOptions.firstChild);
        } else {
          pollOptions.appendChild(cap);
        }
      }
    } catch(e){}
    setPollOptionsVisible(true);
    try{ updateDebugBanner(); }catch(e){}
    // Prewarm covers for current poll choices (quietly), so winner is instant
    try{ schedulePrewarmPollCovers(); }catch(e){}
  }

  function isUserVoted(book) {
    return votes[book]?.includes(voterName);
  }
  function getVoters(book) {
    return votes[book]?.join(", ") || "No votes yet";
  }
  function toggleVote(book) {
    if (!voterName) {
      alert("Please submit your name before voting!");
      return;
    }
    if (!votes[book]) votes[book] = [];
    if (isUserVoted(book)) {
      votes[book] = votes[book].filter(voter => voter !== voterName);
    } else {
      votes[book].push(voterName);
    }
    localStorage.setItem("votes", JSON.stringify(votes));
    updateVoters(book);
    // Sync this voter's selections to Firestore (cross-device updates)
  try{
      if(window.fbSyncAvailable && typeof window.fbSetVotes === 'function'){
        const books = Object.keys(votes).filter(b=> Array.isArray(votes[b]) && votes[b].includes(voterName));
    window.fbSetVotes(voterName, books);
    try{ console.log('[voting_poll] synced votes for', voterName, books); }catch(e){}
      }
    }catch(e){}
  }
  function updateVoters(book) {
    let votersDiv = document.getElementById(slugifyId(book));
    if(!votersDiv){
      try{
        const all = document.querySelectorAll('.voters[data-book]');
        for(const el of all){ if((el.getAttribute('data-book')||'') === String(book)){ votersDiv = el; break; } }
      }catch(e){}
    }
    if (votersDiv) votersDiv.innerHTML = `Voted by: ${getVoters(book)}`;
  // Also update the total votes label
  try{ updateVoteCount(book); }catch(e){}
    // Update the "Total Votes" label below the voters list (poll view)
    try{
      let totalEl = null;
      try{
        const all = document.querySelectorAll('#poll-options .vote-total[data-book]');
        for(const el of all){ if((el.getAttribute('data-book')||'') === String(book)){ totalEl = el; break; } }
      }catch(e){}
      if(totalEl){ const count = Array.isArray(votes[book]) ? votes[book].length : 0; totalEl.textContent = 'Total Votes: ' + count; }
    }catch(e){}
    try{
      let checkbox = null;
      try{
        const allCbs = document.querySelectorAll("input[type='checkbox'][name='poll']");
        for(const cb of allCbs){ if(cb && cb.value === String(book)){ checkbox = cb; break; } }
      }catch(e){}
      const voteLabel = checkbox ? checkbox.parentElement.querySelector('.vote-label') : null;
      if(checkbox){ checkbox.checked = isUserVoted(book); checkbox.disabled = !voterName; }
      if(voteLabel){ if(voterName) voteLabel.classList.add('bold'); else voteLabel.classList.remove('bold'); }
    }catch(e){}
  }
  // Update the Total Votes label for a given book (regular poll)
  function updateVoteCount(book){
    try{
      const count = Array.isArray(votes[book]) ? votes[book].length : 0;
      // Mirror into the Total Votes label under the voters list
      try{
        let totalEl = null; const allTotals = document.querySelectorAll('#poll-options .vote-total[data-book]');
        for(const el of allTotals){ if((el.getAttribute('data-book')||'') === String(book)){ totalEl = el; break; } }
        if(totalEl){ totalEl.textContent = 'Total Votes: ' + count; }
      }catch(e){}
    }catch(e){}
  }
  function submitName() {
    const name = nameInput.value.trim();
    if (!name) {
      try{ nameInput.classList.add('is-invalid'); const err = document.getElementById('nameError'); if(err){ err.textContent='Please enter your name.'; err.classList.add('show'); } }catch(e){}
      try{ nameInput.focus(); nameInput.select && nameInput.select(); }catch(e){}
      return;
    }
    try{ nameInput.classList.remove('is-invalid'); const err = document.getElementById('nameError'); if(err) err.classList.remove('show'); }catch(e){}
    voterName = name;
    nameInput.disabled = true;
    nameInput.style.width = `${name.length + 2}ch`;
    submitNameBtn.style.display = "none";
    editNameBtn.style.display = "inline-block";
    try{ sessionStorage.setItem('voterName', voterName); }catch(e){}

      const checkboxes = document.querySelectorAll('input[type="checkbox"]');
      try{ localStorage.setItem('voterName', voterName); }catch(e){}
    const labels = document.querySelectorAll('.vote-label');
    checkboxes.forEach(checkbox => checkbox.disabled = false);
    labels.forEach(label => label.classList.add('bold'));
    // Undim and re-enable poll interactions now that a name is submitted
  try{ if(pollOptions) pollOptions.classList.remove('poll-needs-name'); }catch(e){}
  try{ const ro = document.getElementById('runoff-options'); if(ro) ro.classList.remove('poll-needs-name'); }catch(e){}
  // After name is set, push current selections (if any) so other devices reflect them
  try{
    if(window.fbSyncAvailable && typeof window.fbSetVotes === 'function'){
      const books = Object.keys(votes).filter(b=> Array.isArray(votes[b]) && votes[b].includes(voterName));
      window.fbSetVotes(voterName, books);
    }
  }catch(e){}
  // Also enable any runoff radio inputs now that we have a name
  try{
    const ro = document.getElementById('runoff-options');
    if(ro){
      Array.from(ro.querySelectorAll('input[type="radio"][name="runoff"]')).forEach(r=> r.disabled = false);
    }
  }catch(e){}
  // Late join enhancement: if user submits name after poll already began, reveal poll with fade-in
  try{ lateJoinRevealIfPollActive(); }catch(e){}
  // Shift focus to first actionable control (checkbox) or status region for accessibility
  try{
    const cb = document.querySelector('#poll-options input[type="checkbox"]');
    if(cb){ cb.focus(); }
    else {
      const st = document.getElementById('poll-status'); if(st){ st.setAttribute('tabindex','-1'); st.focus(); setTimeout(()=> st.removeAttribute('tabindex'), 1000); }
    }
  }catch(e){}
  }
  function editName() {
    nameInput.disabled = false;
    nameInput.style.width = "70%";
    submitNameBtn.style.display = "inline-block";
    editNameBtn.style.display = "none";
    voterName = "";
    try{ localStorage.removeItem('voterName'); }catch(e){}
    const checkboxes = document.querySelectorAll('input[type="checkbox"]');
    const labels = document.querySelectorAll('.vote-label');
    checkboxes.forEach(checkbox => checkbox.disabled = true);
    labels.forEach(label => label.classList.remove('bold'));
  // Hide poll and runoff entirely until a new name is submitted
  try{ setPollOptionsVisible(false); }catch(e){}
  try{ const ro = document.getElementById('runoff-options'); if(ro){ ro.style.display='none'; ro.innerHTML=''; } }catch(e){}
  try{ const status = document.getElementById('poll-status'); if(status){ status.innerHTML=''; } }catch(e){}
  try{ setNameControlsVisible(true); if(nameInput){ nameInput.focus(); } }catch(e){}
  }
  submitNameBtn.addEventListener("click", submitName);
  editNameBtn.addEventListener("click", editName);
  // Allow pressing Enter in the name field to submit; also hide poll when input becomes empty
  try{ if(nameInput){
    nameInput.addEventListener('keydown', function(ev){ if(ev.key === 'Enter'){ ev.preventDefault(); submitName(); } });
    nameInput.addEventListener('input', function(){
      try{
        const publishedAt = localStorage.getItem('pollPublishedAt');
        const v = (nameInput.value||'').trim();
        if(publishedAt && v.length === 0){
          // Treat as no name: hide poll and runoff
          setPollOptionsVisible(false);
          const ro = document.getElementById('runoff-options'); if(ro){ ro.style.display='none'; ro.innerHTML=''; }
        }
      }catch(e){}
    });
  } }catch(e){}

  // Initial render on page load
  renderPollOrWaiting();

  // Helper: when a viewer arrives after poll start and only now submits a name, force-paint poll immediately
  function lateJoinRevealIfPollActive(){
    try{
      const publishedAt = localStorage.getItem('pollPublishedAt');
      const winnerRaw = localStorage.getItem('pollWinner');
      if(winnerRaw){
        try{ const w = JSON.parse(winnerRaw); if(w && w.book){ renderWinner(w.book); return; } }catch(e){}
      }
      if(!publishedAt) return; // no active poll
      const choicesRaw = localStorage.getItem('pollChoices');
      if(choicesRaw){
        // Ensure poll options container visible with fade-in
        try{
          if(pollOptions){
            setPollOptionsVisible(true);
            pollOptions.classList.remove('fade-in');
            // Trigger reflow hack then add fade-in
            void pollOptions.offsetWidth;
            pollOptions.classList.add('fade-in');
          }
        }catch(e){}
        try{ renderPollOrWaiting(); }catch(e){}
      } else {
        // Race: pollChoices not yet in localStorage; run staged retries
        let attempts = 0;
        const schedule = [120, 350, 800, 1500];
        const statusElId = 'late-join-status';
        try{
          let st = document.getElementById(statusElId);
          if(!st){
            st = document.createElement('div');
            st.id = statusElId;
            st.style.fontSize='0.8rem'; st.style.color='#555'; st.style.margin='6px 0 4px';
            st.textContent = 'Loading current poll…';
            const ps = document.getElementById('poll-status'); if(ps) ps.appendChild(st);
          } else { st.textContent = 'Loading current poll…'; }
        }catch(e){}
        function tryLoad(){
          const again = localStorage.getItem('pollChoices');
            if(again){
              try{ const st = document.getElementById(statusElId); if(st) st.textContent=''; }catch(e){}
              try{ setPollOptionsVisible(true); if(pollOptions){ pollOptions.classList.add('fade-in'); } }catch(e){}
              try{ renderPollOrWaiting(); }catch(e){}
              console.log('[late-join] success after attempt', attempts);
              return;
            }
            if(attempts < schedule.length){
              const delay = schedule[attempts++];
              console.log('[late-join] retry in', delay,'ms');
              setTimeout(tryLoad, delay);
            } else {
              console.warn('[late-join] pollChoices still missing after retries');
              try{
                let st = document.getElementById(statusElId);
                if(st){
                  st.innerHTML = 'Poll started but choices not received yet. <button id="lateJoinRetryBtn" style="margin-left:6px;">Retry</button>';
                  const btn = document.getElementById('lateJoinRetryBtn');
                  if(btn){ btn.onclick = ()=>{ st.textContent='Retrying…'; attempts=0; setTimeout(tryLoad, 50); }; }
                }
              }catch(e){}
            }
        }
        setTimeout(tryLoad, schedule[attempts++]);
      }
    }catch(e){ console.warn('[late-join] reveal failed', e); }
  }

  function showPollChoicesAnimated(){
    const target = pollOptions || document.getElementById('poll-options');
    if(!target) return;
    setPollOptionsVisible(true);
    target.classList.remove('fade-in');
    target.classList.add('fade-out');
    setTimeout(()=>{ try{ renderPollOrWaiting(); }catch(e){} target.classList.remove('fade-out'); target.classList.add('fade-in'); }, 350);
  }
  function showWaitingMessage(msg){
    setPollOptionsVisible(false);
    if(pollOptions) pollOptions.innerHTML = '';
    try{ const ro = document.getElementById('runoff-options'); if(ro){ ro.style.display='none'; ro.innerHTML=''; } }catch(e){}
    const target = document.getElementById('poll-status');
    if(!target) return;
    // update debug banner with raw storage for visibility
    try{ debugBanner.textContent = 'local pollChoices: '+ (localStorage.getItem('pollChoices')||'null'); }catch(e){}
    // NEW: If no poll has been published yet AND user has not submitted a name, suppress Merc waiting UI.
    try {
      const publishedAt = localStorage.getItem('pollPublishedAt');
      const savedName = (localStorage.getItem('voterName')||'').trim();
      if(!publishedAt && !savedName){
        target.innerHTML = '';
        return; // defer showing waiting UI until after name is submitted
      }
    } catch(e){}
    if(msg && msg.indexOf && msg.indexOf('Wait until')===0){
      const dogHtml = `
          <div class="wait-box">
            <img class="wait-dog dog-bob" src="../images/Merc.jpg" alt="Merc the dog" loading="lazy" />
            <div class="wait-text">Please wait patiently with Merc — the lead will randomly choose all three books with the slot machine.</div>
            <div class="wait-sub">We'll let you know when voting starts.</div>
            <div class="spinner" aria-hidden="true"></div>
          </div>`;
      target.innerHTML = dogHtml;
      return;
    }
    target.innerHTML = '<div class="text-muted small">'+(msg||'')+'</div>';
  }

  // Render a tiebreaker runoff with single-choice (radio) voting
  function renderRunoff(choices){
    try{
      const ro = document.getElementById('runoff-options');
      if(!ro) return;
      // Hide normal poll UI and waiting status
      setPollOptionsVisible(false);
      const status = document.getElementById('poll-status'); if(status) status.innerHTML='';
      ro.innerHTML = '';
      // Ensure name controls are visible and gating applies
      try{ initNameControlsFromSaved(); }catch(e){}
      ro.style.display='';

  const hdr = document.createElement('div');
      hdr.className = 'mb-2';
      hdr.innerHTML = '<strong>Tiebreaker vote:</strong> select one option';
      ro.appendChild(hdr);
      const groupName = 'runoff';
  const container = document.createElement('div');
      choices.forEach((c, idx)=>{

        const item = document.createElement('div');
        item.className = 'poll-item';
        const id = 'runoff_choice_'+idx;
        const book = (c && (c.book||c.title||c.display||'')) || '';
        const name = (c && (c.name||c.suggestedBy||'')) || '';
        item.innerHTML = `
          <div class="vote-container">
            <input type="radio" id="${id}" name="${groupName}" value="${book}">
            <label for="${id}" class="vote-label">Vote</label>
          </div>
          <div class="poll-content">
            <label for="${id}">${book}</label>
    <div class="suggested-by">Suggested by ${name}</div>
    <div class="voters" id="${slugifyId('runoff-'+book)}" data-book="${book}">Voted by: No votes yet</div>
    <div class="vote-total" data-book="${book}">Total Votes: 0</div>
          </div>`;
        container.appendChild(item);
      });
      ro.appendChild(container);
      // Dim until name present
      try{
        if(!voterName){ ro.classList.add('poll-needs-name'); } else { ro.classList.remove('poll-needs-name'); }
      }catch(e){}
      // Wire radio changes: single vote stored remotely
      Array.from(ro.querySelectorAll('input[type="radio"][name="'+groupName+'"]')).forEach(r =>{
        r.disabled = !voterName;
        r.addEventListener('change', ()=>{

          try{
            if(!voterName){ alert('Please submit your name before voting!'); return; }
            if(window.fbSyncAvailable && typeof window.fbSetRunoffVote === 'function'){
              window.fbSetRunoffVote(voterName, r.value);
            }
          }catch(e){}
        });
      });
      // Hook up live runoff "Voted by" updates
      try{
        if(window.fbSyncAvailable && typeof window.fbSubscribeRunoffVotes === 'function'){
          // Unsubscribe previous if any
          if(window.__unsubRunoffVotes){ try{ window.__unsubRunoffVotes(); }catch(e){} }
          window.__unsubRunoffVotes = window.fbSubscribeRunoffVotes(function(namesByBook){
            try{
              const data = namesByBook || {};
              Object.keys(data).forEach(book=>{
                const elId = slugifyId('runoff-'+book);
                let votersDiv = document.getElementById(elId);
                if(!votersDiv){
                  try{
                    const all = document.querySelectorAll('#runoff-options .voters[data-book]');
                    for(const el of all){ if((el.getAttribute('data-book')||'') === String(book)){ votersDiv = el; break; } }
                  }catch(e){}
                }
                if(votersDiv){ votersDiv.innerHTML = 'Voted by: ' + (data[book] && data[book].length ? data[book].join(', ') : 'No votes yet'); }
                // Update the Total Votes label in runoff
                try{
                  const count = (data[book] && data[book].length) ? data[book].length : 0;
                  try{
                    let totalEl = null; const allTotals = document.querySelectorAll('#runoff-options .vote-total[data-book]');
                    for(const el of allTotals){ if((el.getAttribute('data-book')||'') === String(book)){ totalEl = el; break; } }
                    if(totalEl){ totalEl.textContent = 'Total Votes: ' + count; }
                  }catch(e){}
                }catch(e){}
              });
            }catch(e){ console.warn('[voting_poll] apply runoff votes failed', e); }
          });
        }
      }catch(e){}
    }catch(e){ console.warn('[voting_poll] renderRunoff failed', e); }
  }

  // Render a winner announcement (admin final winner)
  function renderWinner(book){
    try{
      // Hide and clear any poll UI
      setPollOptionsVisible(false);
      try{ if(pollOptions){ pollOptions.innerHTML = ''; } }catch(e){}
      // Hide and clear any runoff UI
      try{
        const ro = document.getElementById('runoff-options');
        if(ro){ ro.style.display='none'; ro.innerHTML=''; }
        if(window.__unsubRunoffVotes){ try{ window.__unsubRunoffVotes(); }catch(e){} window.__unsubRunoffVotes = null; }
      }catch(e){}
      const status = document.getElementById('poll-status');
      if(!status) return;
      const rawBook = String(book||'');
      const safeBook = rawBook.replace(/</g,'&lt;');
      const searchQuery = rawBook.split(' - ')[0].trim();
      const encoded = encodeURIComponent(searchQuery);
      status.innerHTML = `
        <div style="display:flex; justify-content:center;">
          <div class="card shadow-sm" style="padding:16px; text-align:center; max-width:520px; width:100%;">
            <h2 style="margin:0 0 6px 0; font-size:1.4rem;">Winner 🎉</h2>
            <div class="small text-muted">This month's book is:</div>
            <div style="font-size:1.15rem; font-weight:700; margin-top:10px;">${safeBook}</div>
            <div class="winner-cover-wrap"><img id="winner-cover" class="winner-cover" alt="Book cover" width="180" height="270" decoding="async" loading="eager" fetchpriority="high" referrerpolicy="no-referrer" /></div>
            <div class="small text-muted" style="margin-top:14px;">Find this book:</div>
            <div class="winner-links" style="margin-top:8px; display:flex; flex-wrap:wrap; gap:10px; justify-content:center;">
              <a class="btn btn-sm btn-outline-primary" style="min-width:120px;" href="https://www.amazon.com/s?k=${encoded}" target="_blank" rel="noopener noreferrer">Amazon</a>
              <a class="btn btn-sm btn-outline-warning" style="min-width:120px;" href="https://www.audible.com/search?keywords=${encoded}" target="_blank" rel="noopener noreferrer">Audible</a>
            </div>
          </div>
        </div>`;
      // remove outdated pollChoices to avoid reappearance
      try{ localStorage.removeItem('pollChoices'); }catch(e){}
    // Hide any name flow / prompt (issue #31)
    try{ hidePollEntryPrompt(); }catch(e){}
    try{ hideNameControlsAfterWinner(); }catch(e){}
    // Celebrate only if flagged as a live announcement
    try{ if(window.__celebrateWinnerNext){ startConfetti(6000); } }catch(e){}
    try{ window.__celebrateWinnerNext = false; }catch(e){}
    // Async cover load (non-blocking)
    try{ loadWinnerCover(rawBook); }catch(e){}
    }catch(e){ console.warn('[voting_poll] renderWinner error', e); }
  }

  // Lightweight, cached cover loader using Open Library; non-blocking with timeout
  function loadWinnerCover(rawBook){
    try{
      const img = document.getElementById('winner-cover');
      if(!img) { try{ showWinnerCoverPlaceholder(); }catch(e){} return; }
      // Parse "Title - Suggested by Someone" or "Title — Author" patterns
      const titlePart = String(rawBook||'').split(' - ')[0].split(' — ')[0].trim();
      const normKey = titlePart.toLowerCase();
      const cacheNs = 'winnerCoverCache_v1';
      let cache = {};
      try{ cache = JSON.parse(localStorage.getItem(cacheNs)||'{}')||{}; }catch(e){}
      const now = Date.now();
      const hit = cache[normKey];
      if(hit && hit.url && (now - (hit.ts||0) < 14*24*60*60*1000)){
        img.onload = ()=> img.classList.add('ready');
        img.onerror = ()=>{ try{ showWinnerCoverPlaceholder(); }catch(e){} };
        img.src = hit.url;
        return;
      }
      const controller = new AbortController();
      const q = encodeURIComponent(titlePart);
      const searchTimeout = setTimeout(()=>{ try{ controller.abort(); }catch(e){} }, 2500);
      fetch('https://openlibrary.org/search.json?title='+q, { signal: controller.signal })
        .then(r=> r.ok ? r.json() : Promise.reject(new Error('http '+r.status)))
        .then(data=>{
          const docs = (data && Array.isArray(data.docs)) ? data.docs : [];
          // Build a small set of candidate cover URLs (prefer cover_i; fallback to first ISBN)
          const candidates = [];
          for(const d of docs){
            if(!d) continue;
            if(d.cover_i){ candidates.push(`https://covers.openlibrary.org/b/id/${d.cover_i}-L.jpg`); }
            else if(Array.isArray(d.isbn) && d.isbn.length){ candidates.push(`https://covers.openlibrary.org/b/isbn/${d.isbn[0]}-L.jpg`); }
            if(candidates.length >= 5) break;
          }
          if(candidates.length === 0) throw new Error('no candidates');
          // Deduplicate
          const uniq = Array.from(new Set(candidates));
          let resolved = false;
          const finishWith = (url)=>{
            if(resolved) return; resolved = true;
            img.onload = ()=>{
              try{ img.classList.add('ready'); }catch(e){}
              try{ cache[normKey] = { url, ts: Date.now() }; localStorage.setItem(cacheNs, JSON.stringify(cache)); }catch(e){}
            };
            img.onerror = ()=>{ try{ showWinnerCoverPlaceholder(); }catch(e){} };
            img.src = url;
          };
          // Fallback timer to show placeholder if none succeed quickly
          const overallTo = setTimeout(()=>{ if(!resolved){ try{ showWinnerCoverPlaceholder(); }catch(e){} } }, 2200);
          // Try candidates concurrently; first to load wins
          uniq.forEach((u, idx)=>{
            try{
              const probe = new Image();
              probe.decoding = 'async';
              probe.loading = 'eager';
              probe.referrerPolicy = 'no-referrer';
              // Slight stagger to avoid burst
              setTimeout(()=>{
                probe.onload = ()=>{ try{ clearTimeout(overallTo); }catch(e){} finishWith(u); };
                probe.onerror = ()=>{ /* try others */ };
                probe.src = u;
              }, idx * 60);
            }catch(e){}
          });
        })
        .catch(()=>{ try{ showWinnerCoverPlaceholder(); }catch(e){} })
        .finally(()=>{ try{ clearTimeout(searchTimeout); }catch(e){} });
    }catch(e){ try{ showWinnerCoverPlaceholder(); }catch(_){} }
  }

  // Placeholder UI when cover cannot be loaded
  function showWinnerCoverPlaceholder(){
    try{
      const wrap = document.querySelector('.winner-cover-wrap');
      if(!wrap) return;
      const img = document.getElementById('winner-cover');
      if(img){ try{ img.remove(); }catch(e){} }
      if(wrap.querySelector('.winner-cover--placeholder')) return;
      const ph = document.createElement('div');
      ph.className = 'winner-cover winner-cover--placeholder ready';
      ph.innerHTML = '<div class="ph"><span class="ph-line ph-title">This Broke</span><span class="ph-line ph-title">Blame Alice</span></div>';
      wrap.appendChild(ph);
    }catch(e){}
  }

  // Proactive prewarm: fetch likely cover URLs for current poll choices so winner loads instantly
  (function(){
    // Set of normalized titles already prewarmed in this session
    const prewarmed = new Set();
    const cacheNs = 'winnerCoverCache_v1';
    function normalizeTitle(raw){
      try{ return String(raw||'').split(' - ')[0].split(' — ')[0].trim().toLowerCase(); }catch(e){ return String(raw||'').toLowerCase(); }
    }
    function prefetchImage(url){
      try{ const img = new Image(); img.decoding = 'async'; img.loading = 'eager'; img.referrerPolicy = 'no-referrer'; img.src = url; }catch(e){}
      try{
        // Hint browser to prefetch as image
        const l = document.createElement('link'); l.rel = 'prefetch'; l.as = 'image'; l.href = url; document.head.appendChild(l);
      }catch(e){}
    }
    async function prewarmCoverForTitle(rawBook){
      try{
        const titlePart = String(rawBook||'').split(' - ')[0].split(' — ')[0].trim();
        const normKey = titlePart.toLowerCase();
        if(!titlePart || prewarmed.has(normKey)) return; prewarmed.add(normKey);
        let cache = {};
        try{ cache = JSON.parse(localStorage.getItem(cacheNs)||'{}')||{}; }catch(e){}
        const now = Date.now();
        const hit = cache[normKey];
        if(hit && hit.url && (now - (hit.ts||0) < 14*24*60*60*1000)){
          // Already cached recently; just ensure the image is in memory/disk cache
          prefetchImage(hit.url);
          return;
        }
        const controller = new AbortController();
        const to = setTimeout(()=>{ try{ controller.abort(); }catch(e){} }, 1800);
        const q = encodeURIComponent(titlePart);
        const resp = await fetch('https://openlibrary.org/search.json?title='+q, { signal: controller.signal });
        if(!resp.ok) throw new Error('http '+resp.status);
        const data = await resp.json();
        const docs = (data && Array.isArray(data.docs)) ? data.docs : [];
        let picked = null;
        for(const d of docs){ if(d && d.cover_i){ picked = d; break; } }
        if(!picked){ for(const d of docs){ if(d && Array.isArray(d.isbn) && d.isbn.length){ picked = d; break; } } }
        if(!picked) return;
        let url = '';
        if(picked.cover_i){ url = `https://covers.openlibrary.org/b/id/${picked.cover_i}-L.jpg`; }
        else { const isbn = picked.isbn[0]; url = `https://covers.openlibrary.org/b/isbn/${isbn}-L.jpg`; }
        if(url){
          prefetchImage(url);
          try{ cache[normKey] = { url, ts: Date.now() }; localStorage.setItem(cacheNs, JSON.stringify(cache)); }catch(e){}
        }
        try{ clearTimeout(to); }catch(e){}
      }catch(e){ /* silent prewarm */ }
    }
    // Expose a scheduler the poll renderer can call after showing choices
    window.schedulePrewarmPollCovers = function(){
      try{
        const choices = getPollChoices();
        if(!Array.isArray(choices) || !choices.length) return;
        // Stagger requests slightly to stay friendly; limit to first 5
        choices.slice(0,5).forEach((c, i)=>{
          const t = c && (c.book||c.title||c.display||'');
          if(!t) return;
          setTimeout(()=>{ prewarmCoverForTitle(t); }, 80*i);
        });
      }catch(e){}
    };
  })();

  // Lightweight confetti animation (restored)
  function startConfetti(durationMs){
    try{
      const reduce = window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches;
      if(reduce) return;
      // Cleanup any existing animation
      try{ if(window.__confettiCleanup){ window.__confettiCleanup(); window.__confettiCleanup = null; } }catch(e){}
      const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
      const canvas = document.createElement('canvas');
      canvas.className = 'confetti-canvas';
      canvas.width = Math.floor(window.innerWidth * dpr);
      canvas.height = Math.floor(window.innerHeight * dpr);
      canvas.style.width = '100vw';
      canvas.style.height = '100vh';
      const ctx = canvas.getContext('2d');
      ctx.scale(dpr, dpr);
      document.body.appendChild(canvas);
      const colors = ['#E91E63','#9C27B0','#3F51B5','#2196F3','#00BCD4','#4CAF50','#FFC107','#FF5722'];
      const W = () => window.innerWidth;
      const H = () => window.innerHeight;
      const count = Math.max(140, Math.floor(W()/6));
      const gravity = 0.25;
      const drag = 0.005;
      const wind = () => Math.sin(Date.now()/900) * 0.04;
      const rand = (a,b)=> a + Math.random()*(b-a);
      const parts = [];
      for(let i=0;i<count;i++){
        parts.push({
          x: Math.random()*W(), y: rand(-H(), 0),
          w: rand(6,12), h: rand(6,14),
          vx: rand(-0.6,0.6), vy: rand(1.5,3.8),
          rot: rand(0, Math.PI*2), vr: rand(-0.2,0.2),
          col: colors[Math.floor(Math.random()*colors.length)],
          shape: Math.random() < 0.25 ? 'tri' : 'rect',
          alpha: 1
        });
      }
      let rafId = 0;
      let ended = false;
      const endAt = Date.now() + (Number.isFinite(durationMs) ? durationMs : 5000);
      function resize(){
        const ndpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
        if(ndpr !== dpr){ /* keep scale simple; skip live DPR changes */ }
        canvas.width = Math.floor(W()*dpr);
        canvas.height = Math.floor(H()*dpr);
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      }
      const onResize = ()=>{ try{ resize(); }catch(e){} };
      window.addEventListener('resize', onResize);
      function draw(){
        ctx.clearRect(0,0,W(),H());
        const w = wind();
        for(const p of parts){
          p.vx += w;
          p.vx *= (1 - drag);
          p.vy += gravity;
          p.x += p.vx;
          p.y += p.vy;
          p.rot += p.vr;
          // recycle off-screen pieces to the top for a steady shower until duration ends
          if(Date.now() < endAt){
            if(p.y > H()+20 || p.x < -20 || p.x > W()+20){
              p.x = Math.random()*W();
              p.y = -10;
              p.vx = rand(-0.6,0.6); p.vy = rand(1.5,3.8);
            }
          } else {
            // after duration, fade out and let them fall
            p.alpha = Math.max(0, p.alpha - 0.02);
          }
          if(p.alpha <= 0) continue;
          ctx.save();
          ctx.globalAlpha = p.alpha;
          ctx.translate(p.x, p.y);
          ctx.rotate(p.rot);
          ctx.fillStyle = p.col;
          if(p.shape === 'rect'){
            ctx.fillRect(-p.w/2, -p.h/2, p.w, p.h);
          } else {
            ctx.beginPath();
            ctx.moveTo(0, -p.h/2);
            ctx.lineTo(p.w/2, p.h/2);
            ctx.lineTo(-p.w/2, p.h/2);
            ctx.closePath();
            ctx.fill();
          }
          ctx.restore();
        }
        if(Date.now() > endAt + 1200){
          cleanup();
          return;
        }
        rafId = requestAnimationFrame(draw);
      }
      function cleanup(){
        if(ended) return; ended = true;
        cancelAnimationFrame(rafId);
        window.removeEventListener('resize', onResize);
        try{ canvas.remove(); }catch(e){}
      }
      window.__confettiCleanup = cleanup;
      draw();
    }catch(e){ /* noop */ }
  }
  // Banner control (shows when votes are reset via Slot Machine reset)
  const pollResetBanner = document.getElementById('poll-reset-banner');
  function showResetBanner(text){ if(pollResetBanner){ pollResetBanner.textContent = text; pollResetBanner.style.display = 'block'; setTimeout(()=>{ if(pollResetBanner) pollResetBanner.style.display='none'; }, 8000); } }

  // Event listeners for cross-tab and admin events
  // Only respond to published poll notifications and winner announcements via storage events
  window.addEventListener('storage', (ev)=>{
    try{
      // Respect boot-time block
      if(window.__viewerBlockApply){ try{ console.log('[voting_poll] storage ignored due to boot block'); }catch(e){} return; }
      // If viewer chose to ignore server polls, do not react
      if(viewerIsIgnoring()) return;
      // When admin publishes, they set pollPublishedAt; respond to that key only
      if(ev.key === 'pollPublishedAt'){
        try{
          if(ev.newValue){
            // A new publish happened — render poll if pollChoices exist
            console.log('[voting_poll] storage event: pollPublishedAt set');
            try{ renderPollOrWaiting(); }catch(e){}

        try{ updateDebugBanner(); }catch(e){}
          } else {
            // Publish removed — return to waiting UI
            try{ localStorage.removeItem('pollChoices'); }catch(e){}
        try{ renderPollOrWaiting(); }catch(e){}

      try{ updateDebugBanner(); }catch(e){}
          }
        }catch(e){ console.warn('[voting_poll] pollPublishedAt storage handler', e); }
        return;
      }
      // Also respond to pollChoices writes in case admin wrote choices and publishedAt together
    if(ev.key === 'pollChoices' && ev.newValue){ try{ console.log('[voting_poll] storage event: pollChoices changed'); try{ renderPollOrWaiting(); }catch(e){} try{ updateDebugBanner(); }catch(e){} }catch(e){} return; }
      // Winner announcements are respected
      if(ev.key === 'pollWinner' && ev.newValue){
        try{ const p = JSON.parse(ev.newValue); if(p && p.book){ try{ localStorage.removeItem('pollChoices'); }catch(e){} renderWinner(p.book); } }catch(e){}
    try{ updateDebugBanner(); }catch(e){}
        return;
      }
    }catch(e){ console.warn('[voting_poll] storage handler error', e); }
  });
  window.addEventListener('pollPublished', (ev)=>{ try{ renderPollOrWaiting(); }catch(e){} });
  window.addEventListener('pollCleared', (ev)=>{ try{ renderPollOrWaiting(); }catch(e){} });
    // Listen for winner announcements from admin and broadcast channel
  window.addEventListener('pollWinner', (ev)=>{
      try{
        const payload = (ev && ev.detail) || JSON.parse(localStorage.getItem('pollWinner')||'null');
        if(payload && payload.book){
      try{ window.__celebrateWinnerNext = true; }catch(e){}
          // clear any persisted pollChoices so stale polls can't reappear
          try{ localStorage.removeItem('pollChoices'); }catch(e){}
          try{ debugBanner.textContent = 'Winner announced: '+payload.book; }catch(e){}
          // render a special winner UI
          try{ renderWinner(payload.book); }catch(e){ console.log('[voting_poll] winner render failed', e); }
          // stop showing runoff UI once winner is announced
          try{ const ro = document.getElementById('runoff-options'); if(ro){ ro.style.display='none'; ro.innerHTML=''; } }catch(e){}
        }
      }catch(e){ console.warn('[voting_poll] pollWinner handler', e); }
    });
  try{
    const _bc = new BroadcastChannel('book-club');
    _bc.addEventListener('message', (ev)=>{
      try{
        const d = ev.data || {};
        if(window.__viewerBlockApply){ try{ console.log('[voting_poll] BC ignored due to boot block'); }catch(e){} return; }
        if(viewerIsIgnoring()) return;
        if(d && d.type === 'pollWinner' && d.winner){
          try{ window.__celebrateWinnerNext = true; }catch(e){}
          try{ localStorage.setItem('pollWinner', JSON.stringify(d.winner)); }catch(e){}
          try{ localStorage.removeItem('pollChoices'); }catch(e){}
          try{ renderWinner(d.winner.book || d.winner); }catch(e){}
        }
      }catch(e){ console.warn('[voting_poll] BC handler error', e); }
    });
  }catch(e){ /* BroadcastChannel not available; storage events still work */ }
  // Listen for winner announcements via storage events (other tabs)
  window.addEventListener('storage', (ev)=>{
    try{
    // Ignore pollWinner storage events during the boot window to avoid rendering stale winners
    if(window.__viewerBlockApply){ try{ console.log('[voting_poll] storage(pollWinner) ignored due to boot block'); }catch(e){} return; }
      if(ev.key === 'pollWinner' && ev.newValue){
        try{ const p = JSON.parse(ev.newValue); if(p && p.book){ try{ window.__celebrateWinnerNext = true; }catch(e){} try{ localStorage.removeItem('pollChoices'); }catch(e){} renderWinner(p.book); } }catch(e){}
      }
    }catch(e){ console.warn('[voting_poll] storage pollWinner handler', e); }
  });
  window.addEventListener('load', ()=>{

    try{
      const stored = JSON.parse(localStorage.getItem('pollChoices') || 'null');
      const hasPoll = Array.isArray(stored) && stored.length >= 3;
      if(!hasPoll){
        try{ localStorage.removeItem('pollChoices'); }catch(e){}
        try{ if(pollOptions) pollOptions.innerHTML = ''; }catch(e){}
        try{ renderPollOrWaiting(); }catch(e){}
        console.log('[voting_poll] defensive clear ran: no pollChoices present');
      } else {
        console.log('[voting_poll] pollChoices present on load');
      }
      // Migrate session-only ignore flag to persistent localStorage so a prior Clear persists across reloads
      try{
        if(sessionStorage.getItem('viewerIgnoreServerPolls') && !localStorage.getItem('viewerIgnoreServerPolls')){
          localStorage.setItem('viewerIgnoreServerPolls', '1');
          console.log('[voting_poll] migrated viewerIgnoreServerPolls from sessionStorage -> localStorage');
        }
      }catch(e){}
      // If this viewer previously cleared the poll and chose to ignore server polls, reflect that in the UI
      try{
        if(localStorage.getItem('viewerIgnoreServerPolls')){
          try{ debugBanner.textContent = 'Viewer is ignoring server polls'; }catch(e){}
        }
      }catch(e){}
      // Wire up the enter name prompt button
      try{ const enterBtn = document.getElementById('enterNameBtn'); if(enterBtn) enterBtn.addEventListener('click', ()=>{ try{ beginNameFlow(); }catch(e){} }); }catch(e){}
      // If a winner was already announced before this viewer loaded, render winner immediately (issue #31)
      try{
        const existingWinner = JSON.parse(localStorage.getItem('pollWinner')||'null');
        if(existingWinner && existingWinner.book){ renderWinner(existingWinner.book); }
      }catch(e){}
    }catch(e){ console.warn('[voting_poll] defensive clear error', e); }
  });

  // Live cross-device votes subscription (regular poll)
  (function(){
    try{
      if(window.fbSyncAvailable && typeof window.fbSubscribeVotes === 'function'){
    window.fbSubscribeVotes(function(namesByBook){
          try{
      try{ console.log('[voting_poll] remote votes snapshot', namesByBook); }catch(e){}
      // Treat Firestore as source of truth: overwrite local votes with remote
      const incoming = namesByBook || {};
      votes = {};
      Object.keys(incoming).forEach(book=>{ votes[book] = (incoming[book]||[]).slice(); });
            // Refresh UI for visible books
            try{ const pollChoices = getPollChoices(); (pollChoices||[]).forEach(c=> updateVoters(c.book)); }catch(e){}
          }catch(e){ console.warn('[voting_poll] apply remote votes failed', e); }
        });
      }
    }catch(e){}
  })();
</script>
      </div>
    </div>
  </div>
</body>
</html>

<script>
// Failsafe: on some mobile refreshes, scripts may race and render nothing; ensure a waiting UI appears.
(function(){
  function hasContent(el){ try{ return !!(el && String(el.textContent||'').trim().length); }catch(e){ return false; } }
  function ensureNotBlank(){
    try{
      const status = document.getElementById('poll-status');
      const ready = document.getElementById('poll-ready');
      const options = document.getElementById('poll-options');
      const runoff = document.getElementById('runoff-options');
      const winnerEl = document.querySelector('.winner-cover-wrap');
      // Respect name gating: don't auto-insert Merc waiting box if user hasn't submitted a name yet
      let savedName = '';
      let publishedAt = '';
      try { savedName = (localStorage.getItem('voterName')||'').trim(); } catch(e){}
      try { publishedAt = localStorage.getItem('pollPublishedAt')||''; } catch(e){}
      const nothingShown = !winnerEl && (
        !options || options.style.display==='none' || options.children.length===0
      ) && (
        !runoff || runoff.style.display==='none' || runoff.children.length===0
      ) && (
        !ready || ready.classList.contains('d-none') || ready.style.display==='none' || !hasContent(ready)
      ) && (
        !status || !hasContent(status)
      );
      if(nothingShown && status){
        // Only show Merc failsafe if they have already entered a name OR the poll has been published.
        if(savedName || publishedAt){
          status.innerHTML = '<div class="wait-box" data-src="failsafe">\
            <img class="wait-dog dog-bob" src="../images/Merc.jpg" alt="Merc the dog" loading="lazy" />\
            <div class="wait-text">Please wait patiently with Merc — the lead will randomly choose all three books with the slot machine.</div>\
            <div class="wait-sub">We\'ll let you know when voting starts.</div>\
            <div class="spinner" aria-hidden="true"></div>\
          </div>';
        } else {
          // Clear any accidental content so only the name input (prompt) area can be shown by main render function.
          status.innerHTML = '';
        }
      }
    }catch(e){}
  }
  window.addEventListener('load', function(){
    setTimeout(ensureNotBlank, 120);
    setTimeout(ensureNotBlank, 800);
    setTimeout(ensureNotBlank, 2200);
  });
})();
</script>

