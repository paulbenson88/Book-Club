<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
<title>Voting Poll</title>
<link rel="icon" href="/favicon/favicon.ico" type="image/x-icon">
  <!-- Firebase compat SDK (CDN) - replace config below with your project's values -->
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore-compat.js"></script>
  <script>
    (function(){
      const firebaseConfig = {
        apiKey: "AIzaSyAe01ZUiPZfOhUht9XiKPf4brF-NXIkWlE",
        authDomain: "book-club-hub-4bdda.firebaseapp.com",
        projectId: "book-club-hub-4bdda",
        storageBucket: "book-club-hub-4bdda.firebasestorage.app",
        messagingSenderId: "404245538140",
        appId: "1:404245538140:web:956fe120fc1651def00d99",
        measurementId: "G-Z7T8TMH090"
      };
      try{
        if(window.firebase && !window._firestoreInitDone){
          firebase.initializeApp(firebaseConfig);
          window._firestore = firebase.firestore();
          window._firestoreInitDone = true;
          console.log('[voting_poll] Firestore initialized (placeholder)');
          // Subscribe to poll/current document
          const docRef = window._firestore.collection('poll').doc('current');
          console.log('[voting_poll] subscribing to poll/current snapshot');
          docRef.onSnapshot((snap)=>{
            try{
              console.log('[voting_poll] snapshot received', snap && snap.exists);
              if(!snap.exists) return;
              const data = snap.data(); if(!data) return;
              const choices = data.choices || [];
              const str = JSON.stringify(choices);
              if(localStorage.getItem('pollChoices') !== str){
                localStorage.setItem('pollChoices', str);
                try{ window.dispatchEvent(new StorageEvent('storage', { key:'pollChoices', newValue: str })); }catch(e){}
              }
              // Force UI update so viewers immediately render the published poll
              try{
                console.log('[voting_poll] forcing UI update after snapshot');
                if(typeof loadWinnersAndChoices === 'function') try{ loadWinnersAndChoices(); }catch(e){ console.error('[voting_poll] loadWinnersAndChoices failed', e); }
                if(typeof loadPollChoices === 'function') try{ loadPollChoices(); }catch(e){ /* not fatal */ }
                try{ if(typeof showPollChoicesAnimated === 'function') showPollChoicesAnimated(); }catch(e){ /* ignore */ }
              }catch(e){ console.error('[voting_poll] UI update after snapshot failed', e); }
            }catch(e){ console.error('[voting_poll] snapshot handler', e); }
          }, (err)=>{ console.error('[voting_poll] snapshot error', err); });
          // One-time fallback: if snapshot didn't fire quickly, fetch the doc once so incognito pages see current poll
          setTimeout(async ()=>{
            try{
              console.log('[voting_poll] performing one-time get() fallback for poll/current');
              const snap = await docRef.get();
              if(snap && snap.exists){ const data = snap.data(); const choices = data.choices || []; const str = JSON.stringify(choices); if(localStorage.getItem('pollChoices') !== str){ localStorage.setItem('pollChoices', str); try{ window.dispatchEvent(new StorageEvent('storage', { key:'pollChoices', newValue: str })); }catch(e){} try{ loadWinnersAndChoices(); }catch(e){} } }
            }catch(e){ console.warn('[voting_poll] one-time get() failed', e); }
          }, 700);
        }
      }catch(e){ console.warn('[voting_poll] Firestore init failed', e); }
    })();
  </script>
  <style>
    .shadow-sm { box-shadow: 0 1px 2px rgba(0,0,0,0.1); }
    /* transition helpers */
    .fade-in { animation: fadeIn 420ms cubic-bezier(.2,.8,.2,1) both; }
    .fade-out { animation: fadeOut 300ms cubic-bezier(.2,.8,.2,1) both; }
    @keyframes fadeIn { from { opacity: 0; transform: translateY(8px); } to { opacity: 1; transform: none; } }
    @keyframes fadeOut { from { opacity: 1; transform: none; } to { opacity: 0; transform: translateY(-8px); } }
  /* Waiting view styles */
  .wait-box { display:flex; flex-direction:column; align-items:center; gap:12px; padding:12px; }
  .wait-dog { width:220px; max-width:90%; border-radius:12px; box-shadow:0 6px 18px rgba(0,0,0,0.12); }
  .wait-text { font-size:1.05em; color:#333; max-width:380px; text-align:center; }
  .wait-sub { color:#666; font-size:0.95em; }
  .spinner { width:48px; height:48px; border:5px solid #eee; border-top-color:#007bff; border-radius:50%; animation:spin 1s linear infinite; }
  @keyframes spin { to { transform:rotate(360deg); } }
  .dog-bob { animation: bob 2s ease-in-out infinite; }
  @keyframes bob { 0%{transform:translateY(0)}50%{transform:translateY(-6px)}100%{transform:translateY(0)} }
  /* Poll updates are published by admin; no background polling on this page */
  /* small helpers for this page */
  .flex-gap { display:flex; gap:8px; flex-wrap:wrap; }
  .poll-reset-banner { display:none; margin-top:12px; padding:8px; border-radius:6px; background:#fff3cd; color:#856404; border:1px solid #ffeeba; font-size:0.95em; }
  /* Poll responsive fixes: ensure items don't overlap and vote control stays left */
  .poll-item { width:100%; box-sizing:border-box; display:flex; align-items:center; gap:12px; margin:12px 0; padding:12px; border:1px solid #e5e5e5; border-radius:8px; background:#fff; }
  .poll-content { flex:1 1 auto; min-width:0; text-align:left; }
  .vote-container { flex:0 0 86px; display:flex; align-items:center; justify-content:center; padding:8px; border-radius:8px; background:#f6f6f6; border:1px solid #e6e6e6; }
  .vote-container input[type="checkbox"] { transform: scale(1.15); margin-right:8px; }
  .vote-label.bold { font-weight:700; }
  @media (max-width:600px){
    .poll-item { gap:10px; }
    .vote-container { flex:0 0 72px; }
    .vote-container input[type="checkbox"] { transform: scale(1.05); }
    .wait-dog { width:160px; }
  }
  </style>
  <link rel="stylesheet" href="css/styles.css">
  <style>
    /* Overrides after main stylesheet to keep vote control left on mobile */
    @media (max-width:600px) {
      .poll-item { flex-direction: row !important; align-items: center !important; gap: 8px !important; }
      .vote-container { min-width:56px !important; flex: 0 0 56px !important; justify-content: center !important; padding:6px !important; }
      .vote-container input[type="checkbox"] { transform: scale(0.95) !important; }
      .vote-label { display:block; font-size:0.9rem; margin-top:4px; }
      .poll-content label { font-size:1rem; }
      /* Prevent poll cards from collapsing or overlapping */
      #poll-options { overflow: visible; }
    }
  /* Make the name input responsive so it can't overflow the card */
  #nameInput { width:100% !important; max-width:100% !important; box-sizing:border-box !important; display:block; }
  /* Add extra breathing room between the name input and action buttons */
  .name-actions { margin-top:12px !important; gap:12px !important; }
  </style>
</head>

<body>
  <nav class="site-nav">
    <a href="index.html" class="main-page-btn">🏠 Main Page</a>
  </nav>

  <div class="container">
    <div class="card">
      <div class="card-body">
        <!-- Poll updates are published by admin; viewers will react to storage events -->
        <h1 class="card-title">📚 Voting Poll</h1>

        <div id="winners-container" class="mb-3"></div>
        <div id="winners-loading" class="d-none"></div>

        <div class="section">
  <h2>Vote for the next book - toggle your votes</h2>
  <div class="mb-3">
    <input type="text" id="nameInput" placeholder="Enter your name" />
  </div>
  <div class="mb-3 flex-gap name-actions">
  <button id="submitNameBtn" class="cta-primary">Submit Name</button>
  <button id="editNameBtn" class="main-page-btn" style="display:none;">Edit Name</button>
  </div>
  <p class="text-muted small mb-2 mt-2">Please vote for which book(s) you'd like to read next month — you may vote for more than one option.</p>
  <div id="poll-reset-banner" class="poll-reset-banner"></div>
  <!-- Poll UI (legacy) -->
  <div id="poll-options">
      <div class="card shadow-sm">
  <div class="card-body wait-box" style="padding:18px; text-align:center;">
  <img class="wait-dog dog-bob" src="images/Merc.jpg" alt="Merc the dog" loading="lazy" />
          <div class="wait-text">Please wait patiently with Merc — the lead will randomly choose all three books with the slot machine.</div>
          <div class="wait-sub">We'll let you know when voting starts.</div>
          <div class="spinner" aria-hidden="true"></div>
        </div>
  </div>
  </div>

  <!-- Selected Books section removed -->
  <script>
  let pollChoices = JSON.parse(localStorage.getItem("pollChoices")) || []; // Load poll choices
  // Normalize any legacy or internal shapes into {book,name}
  if (Array.isArray(pollChoices) && pollChoices.length){
    pollChoices = pollChoices.map(item => {
      if (!item) return item;
      // accept shapes: {book,name} or {book,title,name} or {title,book,name}
      const book = item.book || item.display || item.title || item[0] || '';
      const name = item.name || item.suggestedBy || item[1] || '';
      return { book: String(book), name: String(name) };
    });
  }
    // persist and render as {book,name} array
    const persisted = pollChoices.map(i => ({ book: i.book, name: i.name || '' }));
    // helper to persist pollChoices and clear votes if the poll changed
    function persistPollChoices(arr){
      try{
        const newStr = JSON.stringify(arr || []);
        const oldStr = localStorage.getItem('pollChoices') || null;
        // If the poll choices changed, clear votes (new poll)
        if(oldStr !== newStr){
          try{ localStorage.removeItem('votes'); }catch(e){}
          // notify other tabs (storage event will fire there)
          try{ window.dispatchEvent(new StorageEvent('storage', { key:'votes', newValue: null })); }catch(e){}
        }
        localStorage.setItem('pollChoices', newStr);
        pollChoices = JSON.parse(newStr);
      }catch(e){ console.warn('persistPollChoices failed', e); }
    }
    persistPollChoices(persisted);
  let votes = JSON.parse(localStorage.getItem("votes")) || {}; // Load votes
  const pollOptions = document.getElementById("poll-options");
  let pollVisible = false; // true when poll UI is currently shown (prevents re-triggering animation)
    const nameInput = document.getElementById("nameInput");
    const submitNameBtn = document.getElementById("submitNameBtn");
    const editNameBtn = document.getElementById("editNameBtn");
    let voterName = ""; // Store the confirmed voter name

    // Display poll options
    function loadPollChoices() {
      pollOptions.innerHTML = ""; // Clear existing options
      pollChoices.forEach((choice, index) => {
        const option = document.createElement("div");
        option.className = "poll-item";
        option.innerHTML = `
          <div class="vote-container">
            <input type="checkbox" id="choice${index}" name="poll" value="${choice.book}">
            <label for="choice${index}" class="vote-label">Vote</label>
          </div>
          <div class="poll-content">
            <label for="choice${index}">${choice.book}</label>
            <div class="suggested-by">Suggested by ${choice.name}</div>
            <div class="voters" id="voters-old-${choice.book}">Voted by: ${getVoters(choice.book)}</div>
          </div>
        `;
        pollOptions.appendChild(option);

        // Wire up checkbox state according to current voterName and votes
        const checkbox = option.querySelector("input[type='checkbox']");
        const voteLabel = option.querySelector('.vote-label');
        // Disabled if no confirmed voter name
        checkbox.disabled = !voterName;
        // Checked if the current voter has voted for this book
        try{ checkbox.checked = isUserVoted(choice.book); }catch(e){}
        if(voterName){ voteLabel.classList.add('bold'); } else { voteLabel.classList.remove('bold'); }
        // Add event listener for toggling votes
        checkbox.addEventListener("change", () => toggleVote(choice.book));
      });
    }

    // Check if the current user has voted for a book
    function isUserVoted(book) {
      return votes[book]?.includes(voterName);
    }

    // Get the list of voters for a book
    function getVoters(book) {
      return votes[book]?.join(", ") || "No votes yet"; // Separate voters with commas
    }

    // Toggle vote for a book
    function toggleVote(book) {
      if (!voterName) {
        alert("Please submit your name before voting!");
        return;
      }

      if (!votes[book]) votes[book] = []; // Initialize votes array for the book

      if (isUserVoted(book)) {
        // Remove the user's vote
        votes[book] = votes[book].filter(voter => voter !== voterName);
      } else {
        // Add the user's vote
        votes[book].push(voterName);
      }

      localStorage.setItem("votes", JSON.stringify(votes)); // Save votes to localStorage
      updateVoters(book); // Update the voters list
    }

    // Update the voters list for a book
    function updateVoters(book) {
  const votersDiv = document.getElementById(`voters-old-${book}`);
  if (votersDiv) votersDiv.innerHTML = `Voted by: ${getVoters(book)}`;
  // Update checkbox checked state and label bolding so re-renders keep correct enable state
  try{
    const checkbox = document.querySelector(`input[type='checkbox'][value="${book}"]`);
    const voteLabel = checkbox ? checkbox.parentElement.querySelector('.vote-label') : null;
    if(checkbox){ checkbox.checked = isUserVoted(book); checkbox.disabled = !voterName; }
    if(voteLabel){ if(voterName) voteLabel.classList.add('bold'); else voteLabel.classList.remove('bold'); }
  }catch(e){}
    }

    // Handle name submission
    function submitName() {
      const name = nameInput.value.trim();
      if (!name) {
        alert("Please enter your name!");
        return;
      }

      voterName = name; // Save the confirmed name
      nameInput.disabled = true; // Disable the name input
      nameInput.style.width = `${name.length + 2}ch`; // Adjust the width to fit the name
      submitNameBtn.style.display = "none"; // Hide the submit button
      editNameBtn.style.display = "inline-block"; // Show the edit button

      // Enable all checkboxes and bold the "Vote" labels
      const checkboxes = document.querySelectorAll('input[type="checkbox"]');
      const labels = document.querySelectorAll('.vote-label');
      checkboxes.forEach(checkbox => checkbox.disabled = false);
      labels.forEach(label => label.classList.add('bold'));
    }

    // Handle name editing
    function editName() {
      nameInput.disabled = false; // Enable the name input
      nameInput.style.width = "70%"; // Reset the width
      submitNameBtn.style.display = "inline-block"; // Show the submit button
      editNameBtn.style.display = "none"; // Hide the edit button
      voterName = ""; // Clear the confirmed name

      // Disable all checkboxes and un-bold the "Vote" labels
      const checkboxes = document.querySelectorAll('input[type="checkbox"]');
      const labels = document.querySelectorAll('.vote-label');
      checkboxes.forEach(checkbox => checkbox.disabled = true);
      labels.forEach(label => label.classList.remove('bold'));
    }

    // Event listeners for name submission and editing
    submitNameBtn.addEventListener("click", submitName);
    editNameBtn.addEventListener("click", editName);

    // Load poll choices on page load
    loadPollChoices();

    // helper to animate showing the poll choices
    function showPollChoicesAnimated(){
      const target = pollOptions || document.getElementById('poll-options');
      if(!target) return;
      // fade out current content (waiting UI) then render poll and fade in
      target.classList.remove('fade-in');
      target.classList.add('fade-out');
      setTimeout(()=>{
        try{ loadPollChoices(); }catch(e){}
        target.classList.remove('fade-out');
        target.classList.add('fade-in');
      }, 350);
    }

    // Global helper to show the waiting UI (used by storage listeners and elsewhere)
    function showWaitingMessage(msg){
      const waitingText = 'Wait until the lead has randomly chosen all three books with the slot machine.';
      const target = document.getElementById('winners-container') || pollOptions;
      if(!target) return;
      if(msg && msg.indexOf && msg.indexOf('Wait until')===0){
        const dogHtml = `
            <div class="wait-box">
              <img class="wait-dog dog-bob" src="images/Merc.jpg" alt="Merc the dog" loading="lazy" />
              <div class="wait-text">Please wait patiently with Merc â€” the lead will randomly choose all three books with the slot machine.</div>
              <div class="wait-sub">We'll let you know when voting starts.</div>
              <div class="spinner" aria-hidden="true"></div>
            </div>`;
        target.innerHTML = dogHtml;
        return;
      }
      target.innerHTML = '<div class="text-muted small">'+(msg||'')+'<\/div>';
    }

  // Banner control (shows when votes are reset via Slot Machine reset)
  const pollResetBanner = document.getElementById('poll-reset-banner');
  function showResetBanner(text){ if(pollResetBanner){ pollResetBanner.textContent = text; pollResetBanner.style.display = 'block'; setTimeout(()=>{ if(pollResetBanner) pollResetBanner.style.display='none'; }, 8000); } }

  // Pull the three chosen indexes from slotMachineState and render titles/names
  async function loadWinnersAndChoices(){
      const CSV_URL = "https://docs.google.com/spreadsheets/d/e/2PACX-1vSLdPdPu4pwIwsAjADiCQOXYUJ8ACgWXaJn0DUVgNEy8ZZfc06EUGz2G9imE4gQ9FRs_zoDamhYTHhQ/pub?output=csv";
      const container = document.getElementById('winners-container');
      const loading = document.getElementById('winners-loading');

      function showMessage(msg){
        // If this is the waiting message, render a friendlier UI with dog and spinner
        const waitingText = 'Wait until the lead has randomly chosen all three books with the slot machine.';
        if(msg && msg.indexOf('Wait until')===0){
          const dogHtml = `
            <div class="wait-box">
              <img class="wait-dog dog-bob" src="images/Merc.jpg" alt="Merc the dog" loading="lazy" />
              <div class="wait-text">Please wait patiently with Merc â€” the lead will randomly choose all three books with the slot machine.</div>
              <div class="wait-sub">We'll let you know when voting starts.</div>
              <div class="spinner" aria-hidden="true"></div>
            </div>`;
          if (container) container.innerHTML = dogHtml;
          else if(pollOptions) pollOptions.innerHTML = dogHtml;
          return;
        }
        const html = '<div class="text-muted small">'+msg+'<\/div>';
        if (container) container.innerHTML = html;
        else if(pollOptions) pollOptions.innerHTML = html;
      }

      // If admin has already published `pollChoices`, use them immediately and render.
      try{
        const stored = JSON.parse(localStorage.getItem('pollChoices') || 'null');
        if(Array.isArray(stored) && stored.length >= 3){
          pollChoices = stored.map(i=>({ book: i.book, name: i.name || '' }));
          try{ persistPollChoices(pollChoices); }catch(e){}
          if(!pollVisible){ try{ showPollChoicesAnimated(); }catch(e){ if(typeof loadPollChoices==='function') loadPollChoices(); } pollVisible = true; }
          return;
        }
      }catch(e){}

      // Try slotMachineState first
      const raw = localStorage.getItem('slotMachineState');
      let chosenIdxs = null;
      if (raw) {
        try {
          const st = JSON.parse(raw);
          if (Array.isArray(st.chosenIdxs)) chosenIdxs = st.chosenIdxs.slice(0,3);
        } catch(e){}
      }

      // Read manual winners from localStorage (if present) and normalize to {book,name}
      const rawManual = JSON.parse(localStorage.getItem('winners') || 'null');
      let manualChoices = Array.isArray(rawManual) ? rawManual.map(w => {
        // accept different shapes: {title,suggestedBy} or {book,name}
        const book = (w && (w.title || w.book || w[0])) || '';
        const name = (w && (w.suggestedBy || w.name || w[1])) || '';
        return { book: String(book).trim() || '(Unknown)', name: String(name).trim() || '' };
      }).filter(x=>x && x.book) : [];

      // If there are no slot choices AND no manual choices, show waiting message
      if ((!chosenIdxs || chosenIdxs.every(v=>v===null || v===undefined)) && manualChoices.length === 0){
        showMessage('Wait until the lead has randomly chosen all three books with the slot machine.');
        return;
      }

      // If manual choices alone satisfy the poll and all have 'name', use them immediately
      const needsName = (arr) => arr.some(x=>!x.name || !String(x.name).trim());
      if (manualChoices.length >= 3 && (!chosenIdxs || chosenIdxs.every(v=>v===null || v===undefined))) {
        const finalManual = manualChoices.slice(0,3);
        // If none are missing names, render fast-path
        if(!needsName(finalManual)){
          pollChoices = finalManual.map(i=>({ book: i.book, name: i.name||'' }));
          try{ persistPollChoices(pollChoices); }catch(e){}
          if(!pollVisible){ try{ showPollChoicesAnimated(); }catch(e){ if (typeof loadPollChoices === 'function') loadPollChoices(); } pollVisible = true; }
          if (typeof window.renderPollOptions === 'function') window.renderPollOptions();
          return;
        }
        // Otherwise fall through to fetch CSV so we can fill missing 'Suggested by' from submissions
      }

      // fetch CSV and map indices -> book/name
      try {
        const res = await fetch(CSV_URL);
        const csv = await res.text();
        const rows = csv.split('\n').slice(1); // skip header
        // helper to normalize book titles for matching
        const norm = s => String(s || '').toLowerCase()
          .replace(/["'â€™â€œâ€\(\)\[\]\.\,;:\-â€”\/]/g,'') // remove punctuation incl. hyphen and em-dash and slashes
          .replace(/\s+/g,' ').trim();
        // parse any CSV line into {display,title,name}
        function parseLineToPair(line){
          const cols = (function(line){
            const out = []; let cur=''; let inQ=false;
            for(let i=0;i<line.length;i++){
              const ch=line[i];
              if(ch==='"'){
                if(inQ && line[i+1]==='"'){ cur+='"'; i++; }
                else inQ = !inQ;
              } else if(ch===',' && !inQ){ out.push(cur); cur=''; }
              else cur+=ch;
            }
            out.push(cur);
            return out;
          })(line);
          // Column heuristic: title is usually in cols[1]; suggester (who suggested the book) in cols[2]
          const rawTitle = (cols[1] || '').trim();
          const suggestedBy = (cols[2] || '').trim();
          // title-only (strip author) for matching
          let titleOnly = rawTitle;
          const dashRe = /\s*-\s*/;
          if(dashRe.test(rawTitle)){
            const parts = rawTitle.split(dashRe);
            titleOnly = parts.slice(0,1).join('-').trim();
          } else {
            const byMatch = rawTitle.match(/\s+by\s+/i);
            if(byMatch){
              const parts = rawTitle.split(/\s+by\s+/i);
              titleOnly = parts[0].trim();
            }
          }
          return { display: rawTitle || '', title: titleOnly || '', name: suggestedBy || '' };
        }
        // Build a lookup from normalized book -> suggestedBy (first match wins)
        const bookToName = {};
        for(let i=0;i<rows.length;i++){
          const raw = rows[i]||'';
          if(!raw.trim()) continue;
          const p = parseLineToPair(raw);
          const k = norm(p.title);
          if(k && !bookToName[k]) bookToName[k] = p.name || '';
        }
        // Build poll choices from chosen indices (slot-derived) using parseLineToPair for consistency
        const slotChoices = [];
        if (Array.isArray(chosenIdxs)) chosenIdxs.forEach((origIdx) => {
          if (origIdx === null || origIdx === undefined) return;
            const row = rows[origIdx] || '';
            const p = parseLineToPair(row);
            slotChoices.push({ book: p.display || p.title || 'Unknown book', title: p.title || '', name: p.name || '' });
        });

        // Merge manualChoices (preferred) with slotChoices to form finalChoices
  const final = [];
  const seen = new Set();
  // Add manual first (if any) using normalized title-only keys
  for(const m of manualChoices){ if(final.length>=3) break; const titleOnly = (function(b){ const parts = String(b||'').split(/\s-\s/); return parts[0]||b||''; })(m.book); const key = norm(titleOnly); if(!seen.has(key)){ final.push({ book: m.book, title: titleOnly, name: m.suggestedBy||m.name||'' }); seen.add(key); } }
  // Fill from slot choices keeping order and avoiding duplicates
  for(const s of slotChoices){ if(final.length>=3) break; const key = norm(s.title||s.book||''); if(!seen.has(key)){ final.push({ book: s.book, title: s.title||s.book, name: s.name||'' }); seen.add(key); } }

        // Fill missing suggestedBy from the CSV lookup using title-only keys
        final.forEach(item => {
          if(!item.name || !String(item.name).trim()){
            const k = norm(item.title || item.book);
            if(k && bookToName[k]) item.name = bookToName[k];
          }
        });

        if (final.length === 3) {
          // Ensure pollChoices are {book, name} (display book and suggestedBy)
          pollChoices = final.map(i=>({ book: i.book, name: i.name||'' }));
          try{ persistPollChoices(pollChoices); }catch(e){}
          // Only reset votes if the slot machine was explicitly Reset
          try{
            if(localStorage.getItem('slotMachineReset')){
              localStorage.removeItem('votes'); votes = {};
              localStorage.removeItem('slotMachineReset'); // consume the flag
            }
          }catch(e){}
          // animate render only once we have all three choices
          if(!pollVisible){
            try{ showPollChoicesAnimated(); }catch(e){ if (typeof loadPollChoices === 'function') loadPollChoices(); }
            pollVisible = true;
          } else {
            // already visible; just ensure UI is up-to-date
            if (typeof loadPollChoices === 'function') loadPollChoices();
          }
          // and notify the other render function if present
          if (typeof window.renderPollOptions === 'function') window.renderPollOptions();
        } else {
          // not ready yet - ensure pollVisible is false so animation can run later
          pollVisible = false;
          showMessage('Wait until the lead has randomly chosen all three books with the slot machine.');
        }
      } catch (err) {
        console.error(err);
        showMessage('Failed to load book details.');
      }
    }

  // Viewers update when admin publishes `pollChoices`.

  // Also listen to storage events (cross-tab) and custom events from admin script
    window.addEventListener('storage', (ev)=>{
      try{
        console.log('[voting_poll] storage event received:', ev && ev.key, ev && ev.newValue);
        // If key is falsy (some synthetic events), fall back to reloading choices to be safe
        if(!ev.key){ loadWinnersAndChoices(); return; }
        if(ev.key==='winners' || ev.key==='slotMachineState' || ev.key==='pollChoices'){
          loadWinnersAndChoices();
          return;
        }
        if(ev.key==='votes'){
          // reload votes and refresh voter displays
          try{ votes = JSON.parse(localStorage.getItem('votes')) || {}; }catch(e){ votes = {}; }
          // update all voter divs and checkbox states
          (pollChoices||[]).forEach(c=> updateVoters(c.book));
          return;
        }
      }catch(e){ console.warn('[voting_poll] storage handler error', e); }
    });

    // Custom events dispatched by admin page when winners are saved/cleared
    window.addEventListener('winnersSaved', (ev)=>{ try{ loadWinnersAndChoices(); }catch(e){} });
  window.addEventListener('winnersCleared', (ev)=>{ try{ pollOptions.innerHTML=''; showWaitingMessage('Wait until the lead has randomly chosen all three books with the slot machine.'); }catch(e){} });

  // Run initial load so waiting UI is shown immediately when no poll is present
  try{ loadWinnersAndChoices(); }catch(e){ console.warn('initial load failed', e); }
  </script>
      </div>
    </div>
  </div>
</body>
</html>

