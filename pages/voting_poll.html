<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
<title>Voting Poll</title>
<link rel="icon" href="/favicon/favicon.ico" type="image/x-icon">
<link rel="preconnect" href="https://openlibrary.org" crossorigin>
<link rel="preconnect" href="https://covers.openlibrary.org" crossorigin>
<link rel="dns-prefetch" href="https://openlibrary.org">
<link rel="dns-prefetch" href="https://covers.openlibrary.org">
<!-- Early migration: ensure viewerIgnore flag is persisted before any snapshot handlers run -->
<script>
  try{
    if(sessionStorage.getItem('viewerIgnoreServerPolls') && !localStorage.getItem('viewerIgnoreServerPolls')){
      localStorage.setItem('viewerIgnoreServerPolls','1');
      console.log('[voting_poll] early migrated viewerIgnoreServerPolls from sessionStorage -> localStorage');
    }
    if(localStorage.getItem('viewerIgnoreServerPolls')){
  // Set a runtime global so later code (including snapshot handlers) can skip work immediately
  try{ window.__viewerIgnoreServerPolls = true; }catch(e){}
      try{ localStorage.removeItem('pollChoices'); }catch(e){}
      console.log('[voting_poll] early cleared local pollChoices because viewerIgnore is set');
  // Debug banner for diagnosing publish/show issues
  function updateDebugBanner(){
    try{
      var banner = document.getElementById('poll-debug-banner');
      if(!banner) return;
      var choices = localStorage.getItem('pollChoices');
      var publishedAt = localStorage.getItem('pollPublishedAt');
      var voterName = localStorage.getItem('voterName');
      banner.textContent = 'debug: pollChoices=' + (choices? 'SET':'') + ' publishedAt=' + (publishedAt? publishedAt:'') + ' voterName=' + (voterName||'');
    }catch(e){console.warn('[voting_poll] updateDebugBanner',e);}    
  }
    }
  }catch(e){ /* ignore */ }
</script>
  <!-- Diagnostics / Instrumentation (Issue #50) -->
  <script>
    (function(){
      try {
        if(!window.__pollDiag){
          window.__pollDiag = {
            log: function(evt, details){
              try{
                const ts = new Date().toISOString();
                const payload = { ts, evt, ...(details||{}) };
                let arr = [];
                try{ arr = JSON.parse(localStorage.getItem('__pollDiagLog')||'[]'); if(!Array.isArray(arr)) arr=[]; }catch(e){}
                arr.push(payload);
                if(arr.length>40) arr.splice(0, arr.length-40);
                try{ localStorage.setItem('__pollDiagLog', JSON.stringify(arr)); }catch(e){}
                console.log('[poll-diagnostic]', evt, payload);
              }catch(e){ /* swallow */ }
            },
            wrapRemove: function(key, reason){
              try {
                const before = localStorage.getItem(key);
                localStorage.removeItem(key);
                this.log('ls.remove', { key, hadValue: before!=null, reason });
              }catch(e){ this.log('ls.remove.error', { key, reason, err: String(e) }); }
            }
          };
        }
      }catch(e){ /* ignore */ }
    })();
  </script>
<!-- Guard utilities for preventing spurious clears -->
<script>
(function(){
  try{
    if(!window.__pollGuards){
      function computeSessionId(pcs, publishedAt){
        try{
          if(!Array.isArray(pcs) || pcs.length < 3) return null;
          const core = (publishedAt||'') + '::' + pcs.map(p=> (p.book||'').trim()).sort().join('|');
          // simple stable hash (FNV-1a like) then base36
          let h = 2166136261>>>0; for(let i=0;i<core.length;i++){ h ^= core.charCodeAt(i); h = Math.imul(h,16777619); }
          return 'ps_'+ (h>>>0).toString(36);
        }catch(e){ return null; }
      }
      function scheduleRestoreCheck(reason){
        try{
          if(window.__restoreTimer) clearTimeout(window.__restoreTimer);
          // Only schedule for empty-type clears (avoid winner / stale)
          if(!/empty|subscribe-empty|applySnapshot-empty/.test(reason)) return;
          const backupRaw = localStorage.getItem('__pollBackup');
          if(!backupRaw) return;
          window.__restoreTimer = setTimeout(()=>{
            try{
              const winner = localStorage.getItem('pollWinner');
              if(winner) return; // winner legit ends poll
              const pcsNow = JSON.parse(localStorage.getItem('pollChoices')||'null');
              if(Array.isArray(pcsNow) && pcsNow.length>=3) return; // already repopulated
              const backup = JSON.parse(backupRaw||'null');
              if(backup && Array.isArray(backup.pcs) && backup.pcs.length>=3){
                localStorage.setItem('pollChoices', JSON.stringify(backup.pcs));
                if(backup.publishedAt) localStorage.setItem('pollPublishedAt', backup.publishedAt);
                if(window.__pollDiag) window.__pollDiag.log('auto-restore', { fromReason: reason });
              }
            }catch(e){ window.__pollDiag && __pollDiag.log('auto-restore.error',{err:String(e)}); }
          }, 1400); // 1.4s confirmation window
        }catch(e){ }
      }
      function clearPoll(reason){
        try{
          const winner = localStorage.getItem('pollWinner');
          const pcs = JSON.parse(localStorage.getItem('pollChoices')||'null');
          const hadValid = Array.isArray(pcs) && pcs.length>=3;
          if(!winner && hadValid && /empty/.test(reason)){
            // strike logic: require 2 consecutive empties
            const strikes = (parseInt(localStorage.getItem('__emptyStrikes')||'0',10) || 0) + 1;
            localStorage.setItem('__emptyStrikes', String(strikes));
            if(strikes < 2){
              window.__pollDiag && __pollDiag.log('defer-clear', { reason, strikes });
              scheduleRestoreCheck(reason); // still schedule restore in case nothing arrives
              return false;
            }
          } else if(!/empty/.test(reason)) {
            // reset strike counter on non-empty reasons
            localStorage.setItem('__emptyStrikes','0');
          }
          // backup before destructive clear
          try{
            const backup = { pcs, votes: JSON.parse(localStorage.getItem('votes')||'{}'), publishedAt: localStorage.getItem('pollPublishedAt'), reason, at: Date.now() };
            localStorage.setItem('__pollBackup', JSON.stringify(backup));
          }catch(e){}
          if(window.__pollDiag) window.__pollDiag.log('clearPoll', { reason, hadValid });
          if(window.__pollDiag){
            __pollDiag.wrapRemove('pollChoices', reason);
            __pollDiag.wrapRemove('pollPublishedAt', reason);
          } else {
            localStorage.removeItem('pollChoices');
            localStorage.removeItem('pollPublishedAt');
          }
          localStorage.setItem('lastClearReason', reason);
          localStorage.setItem('lastClearAt', Date.now().toString());
          scheduleRestoreCheck(reason);
          return true;
        }catch(e){ window.__pollDiag && __pollDiag.log('clearPoll.error',{reason,err:String(e)}); }
      }
      window.__pollGuards = { computeSessionId, clearPoll };
    }
  }catch(e){ }
})();
</script>
<!-- Conditional staleness clearing: only purge obviously old or winner-completed data -->
<script>
  try {
    const publishedAt = localStorage.getItem('pollPublishedAt');
    const winner = localStorage.getItem('pollWinner');
    let isStale = false;
    if (publishedAt) {
      const ageMs = Date.now() - Date.parse(publishedAt);
      if (isNaN(ageMs) || ageMs > 1000*60*60*6) { // older than 6h
        isStale = true;
      }
    }
    if (winner) {
      // After a winner we shouldn't preserve old pollChoices/publishedAt for a new session
      isStale = true;
    }
    if (isStale) {
      try{ window.__pollDiag && __pollDiag.log('stale.clear.begin', { publishedAt, winner }); }catch(e){}
      try{ window.__pollDiag ? __pollDiag.wrapRemove('pollChoices','stale-clear') : localStorage.removeItem('pollChoices'); }catch(e){}
      try{ window.__pollDiag ? __pollDiag.wrapRemove('pollPublishedAt','stale-clear') : localStorage.removeItem('pollPublishedAt'); }catch(e){}
      console.log('[voting_poll] cleared stale poll cache');
    } else {
      console.log('[voting_poll] preserved existing poll cache for potential late join');
    }
  } catch(e) { }
</script>
<!-- Boot-time snapshot queue: queue first snapshot during initial rendering instead of discarding -->
<script>
  try {
    window.__viewerBlockApply = true;
    window.__queuedSnapshot = null;
    console.log('[voting_poll] boot block set (queue mode)');
    setTimeout(()=>{
      try {
        window.__viewerBlockApply = false;
        console.log('[voting_poll] boot block cleared');
        if(window.__queuedSnapshot){
          console.log('[voting_poll] applying queued snapshot now');
          try{ window.__applyPollSnapshot(window.__queuedSnapshot); }catch(e){ console.warn('[voting_poll] queued snapshot apply failed', e); }
          window.__queuedSnapshot = null;
        }
      } catch(e){}
    }, 600);
  } catch(e){}
</script>
  <!-- Firebase compat SDK (CDN). Define window.FIREBASE_CONFIG separately to enable cross-device sync. -->
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-auth-compat.js"></script>
  <script src="../js/firebase-config.js"></script>
  <script src="../js/firebase-sync.js"></script>
  <style>
    .shadow-sm { box-shadow: 0 1px 2px rgba(0,0,0,0.1); }
    /* transition helpers */
    .fade-in { animation: fadeIn 420ms cubic-bezier(.2,.8,.2,1) both; }
    .fade-out { animation: fadeOut 300ms cubic-bezier(.2,.8,.2,1) both; }
    @keyframes fadeIn { from { opacity: 0; transform: translateY(8px); } to { opacity: 1; transform: none; } }
    @keyframes fadeOut { from { opacity: 1; transform: none; } to { opacity: 0; transform: translateY(-8px); } }
  /* Prompt card styling and transitions */
  #poll-ready { transition: opacity 320ms ease, transform 320ms ease; }
  .prompt-card { padding:12px; }
  .prompt-actions { display:flex; gap:10px; margin-top:8px; }
  .prompt-actions .btn { min-width:160px; }
  /* Match site primary CTA look (fallback if site CSS not loaded) */
  .btn.cta-primary, .btn-primary.cta-primary { background:#0d6efd; color:#fff; border:1px solid rgba(0,0,0,0.08); }
  .btn-outline-secondary { border:1px solid #ced4da; background:transparent; color:#333; }
  /* Waiting view styles */
  .wait-box { display:flex; flex-direction:column; align-items:center; gap:12px; padding:12px; }
  .wait-dog { width:220px; max-width:90%; border-radius:12px; box-shadow:0 6px 18px rgba(0,0,0,0.12); }
  .wait-text { font-size:1.05em; color:#333; max-width:380px; text-align:center; }
  .wait-sub { color:#666; font-size:0.95em; }
  .site-nav { margin: 0.02rem 0 0.04rem; display:none !important; }
  .site-nav .main-page-btn { padding: 0.32rem 0.72rem; font-size: 0.86rem; border-radius: 8px; }
  .container { margin-top: 0.02rem; }
  .card { margin-top: 0; }
  .card-body { padding-top: 0.22rem; }
  .card-title.poll-title { margin: 0; display:none !important; }
  #live-slot-preview { margin-top: 0; }
  .live-slot-preview { margin-bottom: 8px; }
  .live-slot-machine {
    background: linear-gradient(180deg, #2f3a52 0%, #1f2738 100%);
    border: 2px solid #d4af37;
    border-radius: 14px;
    padding: 10px;
    box-shadow: 0 8px 22px rgba(0,0,0,0.22);
  }
  .live-slot-title {
    font-weight: 800;
    font-size: 1rem;
    color: #ffe082;
    text-align: center;
    letter-spacing: 0.4px;
    margin-bottom: 8px;
  }
  .live-slot-grid { display: grid; grid-template-columns: 1fr; gap: 5px; }
  .live-slot-reel {
    background: rgba(255,255,255,0.08);
    border: 1px solid rgba(255,255,255,0.14);
    border-radius: 10px;
    padding: 5px;
  }
  .live-slot-slot-label {
    font-size: 0.74rem;
    font-weight: 700;
    color: #d6e2ff;
    letter-spacing: 0.5px;
    margin-bottom: 3px;
    text-transform: uppercase;
    text-align: center;
  }
  .live-slot-window {
    position: relative;
    overflow: hidden;
    background: #fff;
    border: 1px solid #e2e8f0;
    border-radius: 8px;
    min-height: 74px;
    padding: 8px 10px;
  }
  .live-slot-item-main { font-size: 1rem; font-weight: 700; color: #1f2937; line-height: 1.25; text-align: center; }
  .live-slot-item-author { font-size: 0.9rem; font-weight: 600; color: #374151; line-height: 1.2; margin-top: 3px; text-align: center; }
  .live-slot-item-sub { font-size: 0.84rem; color: #4b5563; margin-top: 2px; text-align: center; }
  .live-slot-window.live-slot-spinning .live-slot-item-main { color: #0d6efd; }
  .live-slot-window.live-slot-pending .live-slot-item-main { color: #6b7280; font-weight: 600; }
  .live-slot-window.live-slot-spinning,
  .live-slot-window.live-slot-slowing {
    height: 144px;
    min-height: 144px;
    padding: 0;
    background: #f8fafc;
  }
  .live-slot-window.live-slot-stopped {
    height: 144px;
    min-height: 144px;
    padding: 0;
    background: #f8fafc;
  }
  .live-slot-stopped-content {
    height: 100%;
    width: 100%;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    text-align: center;
    padding: 8px 10px;
    box-sizing: border-box;
  }
  .live-slot-track {
    display: flex;
    flex-direction: column;
    animation: slotRoll 7.2s linear infinite;
    will-change: transform;
  }
  .live-slot-window.live-slot-slowing .live-slot-track {
    animation: slotRollSlow 8.4s linear 1 forwards;
  }
  .live-slot-track-item {
    height: 48px;
    min-height: 48px;
    padding: 6px 9px;
    border-bottom: 1px solid #e5e7eb;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    background: #fff;
    box-sizing: border-box;
  }
  .live-slot-track-item:nth-child(odd) { background: #f9fafb; }
  .live-slot-track-title { font-size: 0.92rem; font-weight: 700; color: #1f2937; line-height: 1.2; text-align: center; }
  .live-slot-track-sub { font-size: 0.76rem; color: #4b5563; margin-top: 2px; text-align: center; }
  .live-slot-window.live-slot-flash {
    animation: slotFlash 900ms ease-out;
    box-shadow: 0 0 0 2px rgba(255,193,7,0.5), 0 0 24px rgba(255,193,7,0.35);
  }
  @keyframes slotRoll {
    from { transform: translateY(0); }
    to { transform: translateY(-50%); }
  }
  @keyframes slotRollSlow {
    0% { transform: translateY(var(--slot-slow-start, 0%)); }
    20% { transform: translateY(var(--slot-slow-p20, -8.7%)); }
    40% { transform: translateY(var(--slot-slow-p40, -15.4%)); }
    60% { transform: translateY(var(--slot-slow-p60, -20.2%)); }
    80% { transform: translateY(var(--slot-slow-p80, -23.0%)); }
    92% { transform: translateY(var(--slot-slow-p92, -23.85%)); }
    100% { transform: translateY(var(--slot-slow-end, -28%)); }
  }
  @keyframes slotFlash {
    0% { transform: scale(1); }
    22% { transform: scale(1.02); }
    100% { transform: scale(1); }
  }
  .spinner { width:48px; height:48px; border:5px solid #eee; border-top-color:#007bff; border-radius:50%; animation:spin 1s linear infinite; }
  @keyframes spin { to { transform:rotate(360deg); } }
  .dog-bob { animation: bob 2s ease-in-out infinite; }
  @keyframes bob { 0%{transform:translateY(0)}50%{transform:translateY(-6px)}100%{transform:translateY(0)} }
  /* Poll updates are published by admin; no background polling on this page */
  /* small helpers for this page */
  .flex-gap { display:flex; gap:8px; flex-wrap:wrap; }
  .poll-reset-banner { display:none; margin-top:12px; padding:8px; border-radius:6px; background:#fff3cd; color:#856404; border:1px solid #ffeeba; font-size:0.95em; }
  /* Poll responsive fixes: ensure items don't overlap and vote control stays left */
  .poll-item { width:100%; box-sizing:border-box; display:flex; align-items:center; gap:12px; margin:12px 0; padding:12px; border:1px solid #e5e5e5; border-radius:8px; background:#fff; }
  .poll-content { flex:1 1 auto; min-width:0; text-align:left; }
  .vote-container { flex:0 0 86px; display:flex; align-items:center; justify-content:center; padding:8px; border-radius:8px; background:#f6f6f6; border:1px solid #e6e6e6; }
  .vote-container input[type="checkbox"] { transform: scale(1.15); margin-right:8px; }
  .vote-label.bold { font-weight:700; }
  @media (max-width:600px){
    .poll-item { gap:10px; }
    .vote-container { flex:0 0 72px; }
    .vote-container input[type="checkbox"] { transform: scale(1.05); }
    .wait-dog { width:160px; }
  }
  /* Dim and disable poll area until voter submits name */
  .poll-needs-name { opacity: 0.6; pointer-events: none; }
  /* Center the poll title (scoped to this page) */
  .poll-title { text-align:center; display:none !important; }
  /* Winner cover */
  .winner-cover-wrap { display:flex; justify-content:center; margin-top:12px; }
  .winner-cover { width: 180px; height: 270px; object-fit: cover; border-radius: 6px; box-shadow: 0 6px 18px rgba(0,0,0,0.15); opacity: 0; transition: opacity 280ms ease; background: #f4f4f4; }
  .winner-cover.ready { opacity: 1; }
  .winner-cover--placeholder { display:flex; align-items:center; justify-content:center; background:#f4f4f4; color:#222; font-weight:800; text-align:center; padding:12px; border:1px dashed #ddd; overflow:hidden; letter-spacing:0.5px; }
  .winner-cover--placeholder .ph { width:100%; }
  .winner-cover--placeholder .ph-line { display:block; }
  .winner-cover--placeholder .ph-line:first-child { margin-bottom:8px; }
  .winner-cover--placeholder .ph-title { font-size: clamp(20px, 5.2vw, 34px); line-height: 1.05; }
  @media (min-width: 768px) { .winner-cover--placeholder .ph-title { font-size: 32px; } }
  </style>
  <link rel="stylesheet" href="../css/styles.css">
  <style>
    /* Overrides after main stylesheet to keep vote control left on mobile */
    @media (max-width:600px) {
      .poll-item { flex-direction: row !important; align-items: center !important; gap: 8px !important; }
      .vote-container { min-width:56px !important; flex: 0 0 56px !important; justify-content: center !important; padding:6px !important; }
      .vote-container input[type="checkbox"] { transform: scale(0.95) !important; }
      .vote-label { display:block; font-size:0.9rem; margin-top:4px; }
      .poll-content label { font-size:1rem; }
      /* Prevent poll cards from collapsing or overlapping */
      #poll-options { overflow: visible; }
    }
  /* Make the name input responsive so it can't overflow the card */
  #nameInput {
    width:100% !important;
    max-width:100% !important;
    box-sizing:border-box !important;
    display:block;
    font-size:16px !important;
    line-height:1.25;
    -webkit-text-size-adjust:100%;
  }
  /* Add extra breathing room between the name input and action buttons */
  .name-actions { margin-top:12px !important; gap:12px !important; }
  /* Confetti overlay */
  .confetti-canvas { position: fixed; inset: 0; width: 100vw; height: 100vh; pointer-events: none; z-index: 9999; }
  /* Total votes label under the voters list */
  .vote-total { color:#555; font-size:0.85rem; margin-top: 2px; }
  .poll-top-row { display:flex; align-items:center; justify-content:space-between; gap:8px; }
  .inline-edit-name-btn { padding:2px 8px !important; font-size:0.74rem !important; line-height:1.15; border-radius:6px; }

  /* Book metadata: short description and outward links */
  .book-meta { margin-top: 6px; display: flex; flex-direction: column; gap: 6px; }
  .book-desc { color:#444; font-size:0.9rem; line-height:1.3; max-width:65ch; min-height:2.6em; white-space:pre-wrap; }
  .book-desc.expanded { overflow:visible; }
  .book-links { display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
  .book-links a { font-size:0.85rem; }
  .book-links .see-more { color:#0d6efd; text-decoration:underline; cursor:pointer; font-size:0.85rem; }
  .poll-content label,
  .winner-title { text-transform: none; }
  /* Prominent name entry panel */
  .name-panel { background:#fff; border:1px solid #e6e6e6; border-radius:10px; padding:12px; box-shadow:0 4px 14px rgba(0,0,0,0.06); max-width:560px; margin:0 auto; }
  .name-title { font-weight:600; margin-bottom:6px; }
  #name-flow.name-saved .name-panel { padding:3px 4px; border-color:#eef2f7; box-shadow:none; max-width:130px; margin-left:auto; margin-right:0; background:transparent; }
  #name-flow.name-saved .name-title { display:none !important; }
  #name-flow.name-saved #nameInput { display:none !important; }
  #name-flow.name-saved .name-actions { display:flex !important; justify-content:flex-end !important; margin-top:0 !important; gap:4px !important; }
  #name-flow.name-saved #submitNameBtn { display:none !important; }
  #name-flow.name-saved #editNameBtn { display:inline-block !important; padding:2px 8px !important; font-size:0.74rem !important; line-height:1.15; border-radius:6px; }
  #name-flow.compact .name-panel { padding:4px 6px; border-color:#eef2f7; box-shadow:none; max-width:220px; margin-left:auto; margin-right:0; background:transparent; }
  #name-flow.compact .name-title { display:none; }
  #name-flow.compact #nameInput { display:none !important; }
  #name-flow.compact .name-actions { margin-top:0 !important; gap:6px !important; justify-content:flex-end; }
  #name-flow.compact #submitNameBtn { display:none !important; }
  #name-flow.compact #editNameBtn { display:inline-block !important; padding:2px 8px !important; font-size:0.76rem !important; line-height:1.2; border-radius:6px; }
  @media (max-width: 700px) {
    #name-flow .name-title { display: none !important; }
    #name-flow #nameInput:disabled { display: none !important; }
    #name-flow #nameInput:disabled ~ .name-actions { justify-content: flex-end !important; margin-top: 0 !important; }
    #name-flow #nameInput:disabled ~ .name-actions #submitNameBtn { display: none !important; }
    #name-flow #nameInput:disabled ~ .name-actions #editNameBtn {
      display: inline-block !important;
      padding: 2px 8px !important;
      font-size: 0.76rem !important;
      line-height: 1.2;
      border-radius: 6px;
    }
  }
  /* Visually gray out the name input when disabled (after submission) */
  #nameInput:disabled {
    background-color: #f5f5f5;
    color: #666;
    border-color: #e0e0e0;
    cursor: not-allowed;
  }
  .name-hint { color:#666; font-size:0.9rem; margin-bottom:8px; }
  #nameInput.is-invalid { border-color:#dc3545; box-shadow: 0 0 0 .2rem rgba(220,53,69,.075); }
  .invalid-feedback { color:#dc3545; font-size:0.85rem; margin-top:6px; display:none; }
  .invalid-feedback.show { display:block; }
  @media(max-width:600px){ .name-panel{ padding:10px; } .name-actions .btn{ width:100%; } }
  </style>
</head>

<body>
  <nav class="site-nav">
    <a href="../index.html" class="main-page-btn">🏠 Main Page</a>
  </nav>

  <div class="container">
    <div class="card">
      <div class="card-body">
        <!-- Poll updates are published by admin; viewers will react to storage events -->
  <h1 class="card-title poll-title">📚 Voting Poll</h1>

  <div id="live-slot-preview" class="live-slot-preview d-none" aria-live="polite"></div>
  <div id="poll-status" class="mb-3"></div>
  <div id="poll-loading" class="d-none"></div>
  <div id="poll-ready" class="mb-3 d-none"></div>

  <!-- Removed empty .section wrapper that caused a small gray box (fixes #30) -->
  <!-- Name input so voters can identify themselves and enable voting (hidden until poll is published) -->
  <div id="name-flow" class="mb-3" style="display:none;">
    <div class="name-panel">
      <div class="name-title">Enter your name to join the vote</div>
      <input type="text" id="nameInput" placeholder="Your name" aria-describedby="nameError" />
      <div id="nameError" class="invalid-feedback" role="alert">Please enter your name.</div>
      <div class="mb-3 flex-gap name-actions" style="display:none;">
        <button id="submitNameBtn" class="btn cta-primary">Submit Name</button>
        <button id="editNameBtn" class="main-page-btn" style="display:none;">Edit Name</button>
      </div>
    </div>
  </div>
  <div id="poll-reset-banner" class="poll-reset-banner"></div>
  <!-- Poll UI (legacy) -->
  <div id="poll-options" style="display:none;"></div>
  <!-- Runoff UI (shown when a tiebreaker runoff is active) -->
  <div id="runoff-options" style="display:none;"></div>

  <!-- Selected Books section removed -->
  <script>
// Attach Firebase listener if config + SDK available and mirror into localStorage for this viewer
(function(){
  try{
    // Expect FIREBASE_CONFIG to be defined globally (provide separately)
    // Load Firebase SDK if not already loaded (viewer previously avoided it)
  }catch(e){}
})();
// Helper to get normalized pollChoices from localStorage
function getPollChoices() {
  let pollChoicesRaw = JSON.parse(localStorage.getItem('pollChoices') || '[]') || [];
  // Normalize possible legacy shapes and filter out empty titles
  let pollChoices = [];
  if (Array.isArray(pollChoicesRaw) && pollChoicesRaw.length){
    pollChoices = pollChoicesRaw.map(item => {
      if (!item) return null;
      const book = item.book || item.display || item.title || item[0] || '';
      const name = item.name || item.suggestedBy || item[1] || '';
      return { book: String(book).trim(), name: String(name).trim() };
    }).filter(x => x && x.book && x.book.length > 0);
  }
  return pollChoices;
}

// Confetti gating: only celebrate on live announcements, not on initial load
window.__celebrateWinnerNext = false;
window.__fbStateInited = false;
window.__lastWinnerBook = null;

// Helpers for safe DOM keys
function slugifyId(text){
  try{ return ('voters-'+String(text||'')).toLowerCase().replace(/[^a-z0-9]+/g,'-').replace(/^-+|-+$/g,''); }catch(e){ return 'voters-unknown'; }
}
function htmlEscape(s){ try{ return String(s||'').replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;'); }catch(e){ return String(s||''); } }

function applyLiveSlotPreview(preview){
  try{ window.__liveSlotPreview = (preview && typeof preview === 'object') ? preview : null; }catch(e){}
  try{ renderLiveSlotPreview(); }catch(e){}
}

function renderLiveSlotPreview(){
  const host = document.getElementById('live-slot-preview');
  const pollTitle = document.querySelector('.poll-title');
  if(!host) return;
  const nowTs = Date.now();
  const preview = window.__liveSlotPreview;
  const publishedAt = localStorage.getItem('pollPublishedAt');
  const winnerRaw = localStorage.getItem('pollWinner');
  const reels = Array.isArray(preview && preview.reels) ? preview.reels.slice(0,3) : [];
  const poolRaw = Array.isArray(preview && preview.entries) ? preview.entries : [];
  const entryPool = poolRaw
    .map(item => ({ book: String((item && item.book) || '').trim(), name: String((item && item.name) || '').trim() }))
    .filter(item => item.book)
    .slice(0, 48);
  const isActive = !!(preview && preview.active && reels.length);
  if(isActive){
    try{ window.__liveSlotLastActiveAt = nowTs; }catch(e){}
    try{ window.__slotSelectionStarted = true; }catch(e){}
  }
  const lastActiveAt = Number(window.__liveSlotLastActiveAt || 0);
  const withinGrace = !isActive && !publishedAt && !winnerRaw && lastActiveAt && ((nowTs - lastActiveAt) < 2500);

  if(withinGrace){
    if(pollTitle) pollTitle.style.display = 'none';
    return;
  }

  if(!isActive || publishedAt || winnerRaw){
    host.classList.add('d-none');
    host.style.display = 'none';
    host.innerHTML = '';
    if(pollTitle) pollTitle.style.display = '';
    try{ window.__liveSlotRenderSig = ''; }catch(e){}
    try{ window.__liveSlotPrevStates = {}; }catch(e){}
    try{ window.__liveSlotPrevRawStates = {}; }catch(e){}
    try{ window.__liveSlotSlowUntil = {}; }catch(e){}
    try{ window.__liveSlotSpinMeta = {}; }catch(e){}
    return;
  }

  const prevStates = (window.__liveSlotPrevStates && typeof window.__liveSlotPrevStates === 'object') ? window.__liveSlotPrevStates : {};
  const prevRawStates = (window.__liveSlotPrevRawStates && typeof window.__liveSlotPrevRawStates === 'object') ? window.__liveSlotPrevRawStates : {};
  const slowUntil = (window.__liveSlotSlowUntil && typeof window.__liveSlotSlowUntil === 'object') ? window.__liveSlotSlowUntil : {};
  const spinMeta = (window.__liveSlotSpinMeta && typeof window.__liveSlotSpinMeta === 'object') ? window.__liveSlotSpinMeta : {};
  const nextStates = {};
  const nextRawStates = {};
  const now = Date.now();
  const rawStates = reels.map(r => String((r && r.state) || 'idle').toLowerCase());
  const isSettledStopped = (idx)=> (rawStates[idx] === 'stopped') && String(prevRawStates[idx] || 'idle') === 'stopped' && !(slowUntil[idx] > now);

  const cards = reels.map((r, idx)=>{
    const state = String((r && r.state) || 'idle').toLowerCase();
    nextRawStates[idx] = state;
    const book = String((r && r.book) || '').trim();
    const splitBookAuthor = (text)=>{
      const raw = String(text || '').trim();
      if(!raw) return { title: '', author: '' };
      const delimiters = [' - ', ' — ', ' – '];
      for(const delim of delimiters){
        const pos = raw.indexOf(delim);
        if(pos > 0){
          const title = raw.slice(0, pos).trim();
          const author = raw.slice(pos + delim.length).trim();
          if(title && author) return { title, author };
        }
      }
      return { title: raw, author: 'Unknown author' };
    };
    const parsed = splitBookAuthor(book);
    const name = String((r && r.name) || '').trim();
    let displayState = 'pending';
    const prevRaw = String(prevRawStates[idx] || 'idle');
    const hasUnsettledBefore = (()=>{
      for(let i=0;i<idx;i++){
        if(!isSettledStopped(i)) return true;
      }
      return false;
    })();

    const rawJustStopped = (state === 'stopped' && prevRaw !== 'stopped');
    if(!hasUnsettledBefore && rawJustStopped && !(slowUntil[idx] > now)){
      slowUntil[idx] = now + 8400;
      try{ setTimeout(()=>{ try{ renderLiveSlotPreview(); }catch(e){} }, 8480); }catch(e){}
    }
    if(state === 'stopped' && !(slowUntil[idx] > now) && !hasUnsettledBefore){
      try{ delete slowUntil[idx]; }catch(e){}
    }

    if(hasUnsettledBefore){
      displayState = 'pending';
    } else if(state === 'spinning'){
      displayState = 'spinning';
    } else if(state === 'stopped' && (slowUntil[idx] > now)){
      displayState = 'slowing';
    } else if(state === 'stopped'){
      displayState = 'stopped';
    }

    nextStates[idx] = displayState;
    if(displayState === 'spinning'){
      const meta = spinMeta[idx] || {};
      if(meta.phase !== 'spinning'){
        spinMeta[idx] = { phase: 'spinning', startedAt: now };
      }
    }
    const justStopped = displayState === 'stopped' && prevStates[idx] !== 'stopped';

    if(displayState === 'stopped' && book){
      const flashClass = justStopped ? ' live-slot-flash' : '';
      return `
        <div class="live-slot-reel live-slot-item live-slot-stopped">
          <div class="live-slot-slot-label">Book ${idx+1}</div>
          <div class="live-slot-window live-slot-stopped${flashClass}">
            <div class="live-slot-stopped-content">
              <div class="live-slot-item-main">${htmlEscape(parsed.title || 'Unknown book')}</div>
              <div class="live-slot-item-author">${htmlEscape(parsed.author || 'Unknown author')}</div>
              <div class="live-slot-item-sub">Suggested by ${htmlEscape(name || 'Unknown')}</div>
            </div>
          </div>
        </div>`;
    }
      if(displayState === 'spinning' || displayState === 'slowing'){
        const priorChosenBooks = new Set();
        for(let j=0;j<idx;j++){
          if(String(rawStates[j] || '').toLowerCase() === 'stopped'){
            const prevBook = String((reels[j] && reels[j].book) || '').trim();
            if(prevBook) priorChosenBooks.add(prevBook.toLowerCase());
          }
        }
        let reelEntries = entryPool.filter(item => !priorChosenBooks.has(String(item.book || '').trim().toLowerCase()));
        if(!reelEntries.length) reelEntries = entryPool.slice();
        if(!reelEntries.length) reelEntries = [{ book: 'Loading submissions…', name: '' }];

        if(book){
          const exists = reelEntries.some(item => String(item.book||'').trim() === book && (!name || String(item.name||'').trim() === name));
          if(!exists) reelEntries = reelEntries.concat([{ book, name: name || '' }]);
        }

        const loopEntries = reelEntries.concat(reelEntries, reelEntries, reelEntries);
      const trackHtml = loopEntries.map(item => `
        <div class="live-slot-track-item">
          <div class="live-slot-track-title">${htmlEscape(item.book)}</div>
          <div class="live-slot-track-sub">${htmlEscape(item.name ? ('Suggested by ' + item.name) : 'Book submission')}</div>
        </div>`).join('');
        let trackStyle = '';
        if(displayState === 'slowing'){
            const itemHeight = 48;
          const n = reelEntries.length;
          let chosenBaseIndex = -1;
          if(book){
            chosenBaseIndex = reelEntries.findIndex(item => item.book === book && (name ? item.name === name : true));
            if(chosenBaseIndex < 0) chosenBaseIndex = reelEntries.findIndex(item => item.book === book);
          }
          if(chosenBaseIndex < 0) chosenBaseIndex = 0;

            const spinDurMs = 7200;
            const prevMeta = spinMeta[idx] || {};
            const startedAt = Number.isFinite(prevMeta.startedAt) ? prevMeta.startedAt : now;
            const elapsed = ((now - startedAt) % spinDurMs + spinDurMs) % spinDurMs;
            const startPct = -50 * (elapsed / spinDurMs);

            const occs = [chosenBaseIndex, n + chosenBaseIndex, (2*n) + chosenBaseIndex, (3*n) + chosenBaseIndex];
          const totalPx = Math.max(itemHeight, loopEntries.length * itemHeight);
            const options = occs.map(occ => {
              const targetPx = -((occ - 1) * itemHeight);
              const endPct = (targetPx / totalPx) * 100;
              const delta = endPct - startPct;
              return { occ, endPct, delta };
            });
            const targetDelta = -30;
            const nearBand = options.filter(o => o.delta <= -18 && o.delta >= -32);
            const forwardOnly = options.filter(o => o.delta <= -8);
            const pool = (nearBand.length ? nearBand : (forwardOnly.length ? forwardOnly : options));
            const chosen = pool.sort((a,b)=> Math.abs(a.delta - targetDelta) - Math.abs(b.delta - targetDelta))[0];

            const endPct = chosen.endPct;
            const delta = endPct - startPct;
            const p20 = startPct + (delta * 0.36);
            const p40 = startPct + (delta * 0.64);
            const p60 = startPct + (delta * 0.84);
            const p80 = startPct + (delta * 0.96);
            const p92 = startPct + (delta * 0.9936);
            spinMeta[idx] = { phase: 'slowing', startedAt, startPct, endPct };
            trackStyle = ` style="--slot-slow-start:${startPct.toFixed(4)}%;--slot-slow-end:${endPct.toFixed(4)}%;--slot-slow-p20:${p20.toFixed(4)}%;--slot-slow-p40:${p40.toFixed(4)}%;--slot-slow-p60:${p60.toFixed(4)}%;--slot-slow-p80:${p80.toFixed(4)}%;--slot-slow-p92:${p92.toFixed(4)}%;"`;
        }
        const spinClass = displayState === 'slowing' ? 'live-slot-slowing' : 'live-slot-spinning';
      return `
        <div class="live-slot-reel live-slot-item live-slot-spinning">
          <div class="live-slot-slot-label">Book ${idx+1}</div>
              <div class="live-slot-window ${spinClass}"${trackStyle}>
            <div class="live-slot-track">${trackHtml}</div>
          </div>
        </div>`;
    }
    return `
      <div class="live-slot-reel live-slot-item live-slot-pending">
        <div class="live-slot-slot-label">Book ${idx+1}</div>
        <div class="live-slot-window live-slot-pending">
          <div class="live-slot-item-main">Waiting…</div>
          <div class="live-slot-item-sub">Not chosen yet</div>
        </div>
      </div>`;
  }).join('');

  try{ window.__liveSlotPrevStates = nextStates; }catch(e){}
  try{ window.__liveSlotPrevRawStates = nextRawStates; }catch(e){}
  try{ window.__liveSlotSlowUntil = slowUntil; }catch(e){}
  try{ window.__liveSlotSpinMeta = spinMeta; }catch(e){}

  const renderSig = JSON.stringify({
    active: !!isActive,
    raw: nextRawStates,
    display: nextStates,
    reels: reels.map(r => ({
      state: String((r && r.state) || '').toLowerCase(),
      book: String((r && r.book) || ''),
      name: String((r && r.name) || '')
    }))
  });
  if(window.__liveSlotRenderSig === renderSig) return;
  try{ window.__liveSlotRenderSig = renderSig; }catch(e){}

  host.innerHTML = `
    <div class="live-slot-machine">
      <div class="live-slot-title">🎰 Live Book Selection</div>
      <div class="live-slot-grid">${cards}</div>
    </div>`;
  if(pollTitle) pollTitle.style.display = 'none';
  host.classList.remove('d-none');
  host.style.display = '';
}

function isLiveSlotPreviewActive(){
  try{
    const preview = window.__liveSlotPreview;
    const publishedAt = localStorage.getItem('pollPublishedAt');
    const winnerRaw = localStorage.getItem('pollWinner');
    const reels = Array.isArray(preview && preview.reels) ? preview.reels.slice(0,3) : [];
    return !!(preview && preview.active && reels.length && !publishedAt && !winnerRaw);
  }catch(e){ return false; }
}

// Book meta helpers: parse "Title - Author" and build links
function parseBookParts(bookStr){
  try{
    const raw = String(bookStr||'').trim();
    // Prefer explicit ' - ' separator; otherwise split on last hyphen
    if(raw.includes(' - ')){
      const parts = raw.split(' - ');
      const title = parts[0] ? parts[0].trim() : raw;
      const author = parts.length>1 ? parts.slice(1).join(' - ').trim() : '';
      return { title, author };
    }
    const idx = raw.lastIndexOf('-');
    if(idx>0){
      const title = raw.slice(0, idx).trim();
      const author = raw.slice(idx+1).trim();
      return { title, author };
    }
    return { title: raw, author: '' };
  }catch(e){ return { title:String(bookStr||''), author:'' }; }
}
function buildGoodreadsUrl(bookStr){
  // Fallback search URL; will be replaced with deep link when resolved
  try{ const {title, author} = parseBookParts(bookStr); return 'https://www.goodreads.com/search?q=' + encodeURIComponent(title + (author?(' '+author):'')); }catch(e){ return 'https://www.goodreads.com/'; }
}
function normalizeBookKey(s){
  try{ return String(s||'').toLowerCase().replace(/\s*-[\s\u00A0]*?/g,' - ').replace(/\s+/g,' ').trim(); }catch(e){ return String(s||'').toLowerCase().trim(); }
}
function normalizeLooseKey(s){
  try{
    return String(s||'')
      .toLowerCase()
      .replace(/[’']/g,'')
      .replace(/[^a-z0-9\s-]/g,' ')
      .replace(/\s+by\s+/g,' - ')
      .replace(/\s*-\s*/g,' - ')
      .replace(/\s+/g,' ')
      .trim();
  }catch(e){ return String(s||'').toLowerCase().trim(); }
}
function formatBookDisplayTitle(raw){
  try{
    const s = String(raw||'').trim();
    if(!s) return '';
    const hasMixedCase = /[A-Z]/.test(s.slice(1));
    if(hasMixedCase) return s;
    return s.toLowerCase().replace(/\b([a-z])/g, (_, ch)=> ch.toUpperCase());
  }catch(e){ return String(raw||''); }
}
function trimToPreview(text, opts){
  try{
    const s0 = String(text||'');
    // Normalize whitespace early to get stable sentence detection
    const s = s0.replace(/\s+/g,' ').trim();
    if(!s) return '';
    const maxChars = Math.max(120, (opts && opts.maxChars) || 320);
    const maxSentences = Math.max(1, (opts && opts.maxSentences) || 3);
    // Split into sentences, keeping punctuation
    const parts = s.match(/[^.!?]+[.!?]/g) || [s];
    let out = '';
    for(let i=0;i<parts.length && i<maxSentences; i++){
      const next = (out ? (out + ' ') : '') + parts[i].trim();
      if(next.length > maxChars){ break; }
      out = next;
    }
    if(!out){
      out = s.slice(0, maxChars - 1).replace(/[,;:\s]+$/,'').trim();
    }
    if(out.length < s.length){
      out = out.replace(/[\s]+$/,'') + '…';
    }
    return out;
  }catch(e){ return ''; }
}
function toOneLiner(text){
  try{
    const s = String(text||'').replace(/\s+/g,' ').trim();
    if(!s) return '';
    const parts = (s.match(/[^.!?]+[.!?]/g) || [s]).map(p=>String(p||'').trim()).filter(Boolean);
    const weakOpenRe = /^(in\s+the\s+year\s+\d{3,4}|the\s+end\s+was\s+near|it\s+was\s+\d|there\s+was\s+|once\s+upon\s+a\s+time)/i;
    const score = (sent)=>{
      const words = sent.split(/\s+/).filter(Boolean);
      const wc = words.length;
      let sc = wc;
      if(wc >= 12) sc += 12;
      if(/\b(novel|story|follows|about|chronicles|journey|surviv|war|mystery|thriller|fantasy|dystopia|zombie|virtual|quest|mission|family|murder)\b/i.test(sent)) sc += 10;
      if(weakOpenRe.test(sent)) sc -= 14;
      if(wc < 8) sc -= 8;
      return sc;
    };
    let best = parts[0] || s;
    let bestScore = score(best);
    for(const p of parts.slice(1,4)){
      const sc = score(p);
      if(sc > bestScore){ best = p; bestScore = sc; }
    }
    let out = best.trim();
    if(out.length > 220) out = out.slice(0, 219).replace(/[\s,;:]+$/,'') + '…';
    return out;
  }catch(e){ return ''; }
}
function getSummaryOverride(bookStr){
  try{
    const map = window.__summaryOverrides || {};
    const direct = map[normalizeBookKey(bookStr)];
    if(direct && String(direct).trim().length) return String(direct).trim();
    const looseTarget = normalizeLooseKey(bookStr);
    // Fast exact loose-key pass
    for(const k of Object.keys(map)){
      if(normalizeLooseKey(k) === looseTarget){
        const v = map[k];
        if(v && String(v).trim().length) return String(v).trim();
      }
    }
    // Token-overlap fallback for minor typos (e.g., "readyt player one")
    const toksA = new Set(looseTarget.split(/\s+/).filter(t=>t && t !== '-'));
    let best = ''; let bestScore = 0;
    for(const k of Object.keys(map)){
      const toksB = new Set(normalizeLooseKey(k).split(/\s+/).filter(t=>t && t !== '-'));
      let common = 0;
      toksA.forEach(t=>{ if(toksB.has(t)) common++; });
      const denom = Math.max(toksA.size, toksB.size, 1);
      const j = common / denom;
      if(j > bestScore){ bestScore = j; best = k; }
    }
    if(best && bestScore >= 0.6){
      const v = map[best];
      if(v && String(v).trim().length) return String(v).trim();
    }
    return '';
  }catch(e){ return ''; }
}
async function fetchWithTimeout(url, ms){
  const ctrl = new AbortController(); const id = setTimeout(()=>ctrl.abort(), ms||2500);
  try{ const res = await fetch(url, {signal: ctrl.signal, credentials:'omit'}); return res; } finally { clearTimeout(id); }
}
// Firestore-backed metadata via Functions (if available): url/description cache
async function fetchBookMetaIfAvailable(bookStr){
  try{
    const serverBase = (window.GOODREADS_RESOLVER_URL || localStorage.getItem('grResolverBase') || '').replace(/\/$/,'');
    const isFunctionsEndpoint = /cloudfunctions\.net|run\.app/i.test(serverBase) || /resolveGoodreads$/i.test(serverBase);
    if(!isFunctionsEndpoint) return null; // meta API only on Firebase Functions
    const root = serverBase.replace(/\/resolveGoodreads$/i,'');
    const enc = encodeURIComponent(bookStr);
    const url = root + '/getBookMeta?q=' + enc;
    const resp = await fetchWithTimeout(url, 4000);
    if(resp && resp.ok){ const data = await resp.json().catch(()=>null); if(data && (data.url || data.description || data.summary)) return data; }
    return null;
  }catch(_){ return null; }
}
// Goodreads overrides loader (optional JSON in repo)
async function ensureGoodreadsOverridesLoaded(){
  try{
    if(typeof window.__grOverrides !== 'undefined') return;
    window.__grOverrides = {};
    const candidates = [
      '../goodreads-overrides.json',
      '/goodreads-overrides.json',
      './goodreads-overrides.json'
    ];
    for(const url of candidates){
      try{
        const res = await fetch(url, {credentials:'omit'});
        if(res && res.ok){
          const data = await res.json();
          if(data && typeof data === 'object'){ window.__grOverrides = data; }
          break;
        }
      }catch(_){ /* try next */ }
    }
  }catch(e){ window.__grOverrides = window.__grOverrides || {}; }
}
// Summary overrides loader (optional JSON in repo)
async function ensureSummaryOverridesLoaded(){
  try{
    const hasLoadedData = !!(window.__summaryOverrides && typeof window.__summaryOverrides === 'object' && Object.keys(window.__summaryOverrides).length);
    if(hasLoadedData) return;

    if(window.__summaryOverridesLoadPromise){
      try{ await window.__summaryOverridesLoadPromise; }catch(_){ }
      const nowHasData = !!(window.__summaryOverrides && typeof window.__summaryOverrides === 'object' && Object.keys(window.__summaryOverrides).length);
      if(nowHasData) return;
    }

    window.__summaryOverridesLoadPromise = (async ()=>{
      window.__summaryOverrides = window.__summaryOverrides && typeof window.__summaryOverrides === 'object' ? window.__summaryOverrides : {};
      const candidates = [
        '../book-summaries.json',
        '/book-summaries.json',
        './book-summaries.json'
      ];
      for(const url of candidates){
        try{
          const res = await fetch(url, { credentials:'omit', cache:'no-store' });
          if(res && res.ok){
            const data = await res.json();
            if(data && typeof data === 'object' && Object.keys(data).length){
              window.__summaryOverrides = data;
              return;
            }
          }
        }catch(_){ /* try next */ }
      }
    })();

    try{ await window.__summaryOverridesLoadPromise; }catch(_){ }
    finally { try{ window.__summaryOverridesLoadPromise = null; }catch(_){ } }
  }catch(e){ window.__summaryOverrides = window.__summaryOverrides || {}; }
}
async function tryFetchOpenLibraryDescription(bookStr){
  try{
    const {title, author} = parseBookParts(bookStr);
    const q = 'https://openlibrary.org/search.json?title=' + encodeURIComponent(title) + (author?('&author='+encodeURIComponent(author)):'') + '&limit=1';
    const sres = await fetchWithTimeout(q, 2500);
    if(!sres.ok) throw new Error('search '+sres.status);
    const sj = await sres.json();
    const doc = Array.isArray(sj && sj.docs) && sj.docs.length ? sj.docs[0] : null;
    if(!doc) return '';
    let workKey = '';
    if(doc.key && String(doc.key).startsWith('/works/')) workKey = doc.key;
    else if(Array.isArray(doc.work_key) && doc.work_key.length) workKey = '/works/'+doc.work_key[0];
    if(!workKey) return '';
    const wres = await fetchWithTimeout('https://openlibrary.org'+workKey+'.json', 2500);
    if(!wres.ok) throw new Error('work '+wres.status);
    const wj = await wres.json();
    let desc = (wj && wj.description) ? wj.description : '';
    if(desc && typeof desc === 'object' && desc.value) desc = desc.value;
    if(!desc && wj && wj.first_sentence){ desc = typeof wj.first_sentence==='string' ? wj.first_sentence : (wj.first_sentence && wj.first_sentence.value)||''; }
    // Return full text; UI will handle preview collapsing
    return String(desc||'');
  }catch(e){ return ''; }
}
async function tryResolveGoodreadsUrl(bookStr){
  try{
    const {title, author} = parseBookParts(bookStr);
    // Canonicalize to "Title - Author" when missing separator or likely misspelled
    async function canonicalizeBookStr(rawTitle, rawAuthor){
      try{
        const raw = String((rawTitle||'') + (rawAuthor?(' - '+rawAuthor):'')).trim();
        const ckey = 'canon:'+raw;
        try{ const cached = localStorage.getItem(ckey); if(cached){ return cached; } }catch(_){ }
        const needs = !rawAuthor || !/\s-\s/.test(String(bookStr));
        if(!needs) return raw;
        // Try Open Library: title+author then title-only
        let doc = null;
        try{
          let r = await fetchWithTimeout('https://openlibrary.org/search.json?title=' + encodeURIComponent(rawTitle) + (rawAuthor?('&author='+encodeURIComponent(rawAuthor)):'') + '&limit=10', 2500);
          if(r.ok){ const j = await r.json(); const ds = Array.isArray(j && j.docs)? j.docs: []; if(ds.length) doc = ds[0]; }
          if(!doc){
            r = await fetchWithTimeout('https://openlibrary.org/search.json?title=' + encodeURIComponent(rawTitle) + '&limit=10', 2500);
            if(r.ok){ const j2 = await r.json(); const ds2 = Array.isArray(j2 && j2.docs)? j2.docs: []; if(ds2.length) doc = ds2[0]; }
          }
        }catch(_){ }
        if(doc){
          const t = (doc.title || doc.title_suggest || rawTitle || '').toString().trim();
          const a = (Array.isArray(doc.author_name) && doc.author_name[0]) ? String(doc.author_name[0]).trim() : (rawAuthor||'');
          const canon = (t && a) ? (t + ' - ' + a) : (t || raw);
          try{ localStorage.setItem(ckey, canon); }catch(_){ }
          return canon;
        }
        return raw;
      }catch(_){ return String((rawTitle||'') + (rawAuthor?(' - '+rawAuthor):'')); }
    }
    const canonical = await canonicalizeBookStr(title, author);
    const keyBookStr = canonical || bookStr;
    // Curated overrides for exact Goodreads pages (from JSON file if present)
    function normalizeBookKey(s){ try{ return String(s||'').toLowerCase().replace(/\s*-[\s\u00A0]*?/g,' - ').replace(/\s+/g,' ').trim(); }catch(_){ return String(s||''); } }
    await ensureGoodreadsOverridesLoaded();
    const override = (window.__grOverrides && window.__grOverrides[normalizeBookKey(keyBookStr)]) || null;
    if(override){ return override; }
    const cacheKey = 'grUrl:'+keyBookStr;
    try{
      const c = localStorage.getItem(cacheKey);
      if(c && /\/book\/(show|isbn)\//.test(c)) return c; // only trust cached deep links
    }catch(_){ }
    // Prefer cached metadata (Firestore via Functions) if available
    try{
      const meta = await fetchBookMetaIfAvailable(keyBookStr);
      const u = meta && meta.url;
      if(u && /\/book\/(show|isbn)\//.test(u)){ try{ localStorage.setItem(cacheKey, u); }catch(_){} return u; }
    }catch(_){ }
    // Prefer server resolver if configured (deep links only)
    const serverBase = (window.GOODREADS_RESOLVER_URL || localStorage.getItem('grResolverBase') || '').replace(/\/$/,'');
    if(serverBase){
      try{
        const enc = encodeURIComponent(keyBookStr);
        const isFunctionsEndpoint = /cloudfunctions\.net|run\.app/i.test(serverBase) || /resolveGoodreads$/i.test(serverBase);
        const endpoint = serverBase + (isFunctionsEndpoint ? ('?q=' + enc) : ('/resolve?q=' + enc));
        const resp = await fetch(endpoint, { credentials: 'omit' });
        if(resp && resp.ok){ const data = await resp.json().catch(()=>null); const u = data && data.url; if(u && /\/book\/(show|isbn)\//.test(u)){ try{ localStorage.setItem(cacheKey, u); }catch(_){} return u; } }
      }catch(_e){ /* fall through to client resolver */ }
    }
  const {title: t0, author: a0} = parseBookParts(keyBookStr);
  let q = 'https://openlibrary.org/search.json?title=' + encodeURIComponent(t0) + (a0?('&author='+encodeURIComponent(a0)):'') + '&limit=10';
  let sres = await fetchWithTimeout(q, 3000);
  if(!sres.ok) throw new Error('search '+sres.status);
  let sj = await sres.json();
  let docs = Array.isArray(sj && sj.docs) ? sj.docs.slice(0,10) : [];
    // helper to store and return
    const ok = (url)=>{ try{ if(/\/book\/(show|isbn)\//.test(url)) localStorage.setItem(cacheKey, url); }catch(_){} return url; };
    for(const doc of docs){
      if(!doc) continue;
      // 1) Direct goodreads id on search doc
      if(Array.isArray(doc.id_goodreads) && doc.id_goodreads.length){
        const id = String(doc.id_goodreads[0]).replace(/[^0-9]/g,'');
        if(id) return ok('https://www.goodreads.com/book/show/' + id);
      }
      // 2) Edition identifiers.goodreads on first few editions
      const eds = Array.isArray(doc.edition_key) ? doc.edition_key.slice(0,3) : [];
      for(const ed of eds){
        try{
          const eres = await fetchWithTimeout('https://openlibrary.org/books/'+ed+'.json', 2500);
          if(!eres.ok) continue;
          const ej = await eres.json();
          const gr = ej && ej.identifiers && (ej.identifiers.goodreads || ej.identifiers['goodreads']);
          if(Array.isArray(gr) && gr.length){
            const id = String(gr[0]).replace(/[^0-9]/g,'');
            if(id) return ok('https://www.goodreads.com/book/show/' + id);
          }
          // ISBN fallback
          const isbn13 = ej && ej.identifiers && Array.isArray(ej.identifiers.isbn_13) && ej.identifiers.isbn_13[0];
          const isbn10 = ej && ej.identifiers && Array.isArray(ej.identifiers.isbn_10) && ej.identifiers.isbn_10[0];
          const isbn = (isbn13 || isbn10 || '').toString().replace(/[^0-9Xx]/g,'');
          if(isbn){ return ok('https://www.goodreads.com/book/isbn/' + isbn); }
        }catch(_){}
      }
      // 3) Work links sometimes include Goodreads
      const workKey = (doc.key && String(doc.key).startsWith('/works/')) ? doc.key : (Array.isArray(doc.work_key) && doc.work_key.length ? ('/works/'+doc.work_key[0]) : '');
      if(workKey){
        try{
          const wres = await fetchWithTimeout('https://openlibrary.org'+workKey+'.json', 2500);
          if(wres.ok){
            const wj = await wres.json();
            if(Array.isArray(wj && wj.links)){
              const link = wj.links.find(l => l && l.url && /goodreads\.com/i.test(l.url));
              if(link && link.url) return ok(link.url);
            }
          }
        }catch(_){ }
        // Try editions enumeration for Goodreads IDs / ISBNs
        try{
          const el = await fetchWithTimeout('https://openlibrary.org'+workKey+'/editions.json?limit=25', 2500);
          if(el.ok){
            const ej = await el.json();
            const entries = Array.isArray(ej && ej.entries) ? ej.entries : [];
            for(const ent of entries){
              const ids = ent && ent.identifiers || {};
              const gr = ids.goodreads || ids['goodreads'];
              if(Array.isArray(gr) && gr.length){ const id = String(gr[0]).replace(/[^0-9]/g,''); if(id) return ok('https://www.goodreads.com/book/show/' + id); }
              const isbn13 = Array.isArray(ids.isbn_13) && ids.isbn_13[0];
              const isbn10 = Array.isArray(ids.isbn_10) && ids.isbn_10[0];
              const isbn = (isbn13 || isbn10 || '').toString().replace(/[^0-9Xx]/g,'');
              if(isbn){ return ok('https://www.goodreads.com/book/isbn/' + isbn); }
            }
          }
        }catch(_){ }
      }
      // 4) Search doc isbn arrays
      if(Array.isArray(doc.isbn) && doc.isbn.length){
        const isb = String(doc.isbn[0]).replace(/[^0-9Xx]/g,'');
        if(isb){ return ok('https://www.goodreads.com/book/isbn/' + isb); }
      }
    }
    // If nothing found, try a title-only search (helps misspellings)
    if(!docs.length){
      q = 'https://openlibrary.org/search.json?title=' + encodeURIComponent(title) + '&limit=10';
      sres = await fetchWithTimeout(q, 3000);
      if(sres.ok){ sj = await sres.json(); docs = Array.isArray(sj && sj.docs) ? sj.docs.slice(0,10) : []; }
      for(const doc of docs){
        if(!doc) continue;
        // Prefer same resolution steps
        if(Array.isArray(doc.id_goodreads) && doc.id_goodreads.length){ const id = String(doc.id_goodreads[0]).replace(/[^0-9]/g,''); if(id) return ok('https://www.goodreads.com/book/show/' + id); }
        const eds2 = Array.isArray(doc.edition_key) ? doc.edition_key.slice(0,3) : [];
        for(const ed of eds2){
          try{
            const eres = await fetchWithTimeout('https://openlibrary.org/books/'+ed+'.json', 2500);
            if(!eres.ok) continue;
            const ej = await eres.json();
            const gr = ej && ej.identifiers && (ej.identifiers.goodreads || ej.identifiers['goodreads']);
            if(Array.isArray(gr) && gr.length){ const id = String(gr[0]).replace(/[^0-9]/g,''); if(id) return ok('https://www.goodreads.com/book/show/' + id); }
            const isbn13 = ej && ej.identifiers && Array.isArray(ej.identifiers.isbn_13) && ej.identifiers.isbn_13[0];
            const isbn10 = ej && ej.identifiers && Array.isArray(ej.identifiers.isbn_10) && ej.identifiers.isbn_10[0];
            const isbn = (isbn13 || isbn10 || '').toString().replace(/[^0-9Xx]/g,'');
            if(isbn){ return ok('https://www.goodreads.com/book/isbn/' + isbn); }
          }catch(_){}
        }
        const workKey2 = (doc.key && String(doc.key).startsWith('/works/')) ? doc.key : (Array.isArray(doc.work_key) && doc.work_key.length ? ('/works/'+doc.work_key[0]) : '');
        if(workKey2){
          try{
            const wres = await fetchWithTimeout('https://openlibrary.org'+workKey2+'.json', 2500);
            if(wres.ok){ const wj = await wres.json(); if(Array.isArray(wj && wj.links)){ const link = wj.links.find(l => l && l.url && /goodreads\.com/i.test(l.url)); if(link && link.url) return ok(link.url); } }
          }catch(_){}
        }
        if(Array.isArray(doc.isbn) && doc.isbn.length){ const isb = String(doc.isbn[0]).replace(/[^0-9Xx]/g,''); if(isb){ return ok('https://www.goodreads.com/book/isbn/' + isb); } }
      }
    }
    // Do not force a search URL override; keep whatever the caller had (usually search)
    return '';
  }catch(e){ return ''; }
}
async function resolveAndApplyGoodreads(bookStr, container){
  try{
    if(!container) return;
    const link = container.querySelector('a.goodreads-link');
    if(!link) return;
    // First, try Firestore meta (if hosted on Firebase)
    try{
      const meta = await fetchBookMetaIfAvailable(bookStr);
      const u0 = meta && meta.url;
      if(u0 && /\/book\/(show|isbn)\//.test(u0)){ link.href = u0; return; }
    }catch(_){ }
    const url = await tryResolveGoodreadsUrl(bookStr);
    if(url && /\/book\/(show|isbn)\//.test(url)){
      link.href = url; // only apply deep links; leave search link otherwise
    }
  }catch(_e){}
}
function scheduleDescriptionRetry(bookStr, mountEl){
  try{
    if(!mountEl) return;
    const maxAttempts = 3;
    const attempts = parseInt(mountEl.dataset.descAttempts || '0', 10) || 0;
    if(attempts >= maxAttempts) return;
    const delays = [1500, 3500, 8000];
    const delay = delays[Math.min(attempts, delays.length - 1)];
    mountEl.dataset.descAttempts = String(attempts + 1);
    setTimeout(function(){
      try{
        if(!mountEl) return;
        if(mountEl.dataset && mountEl.dataset.full && String(mountEl.dataset.full).trim().length) return;
        if(mountEl.textContent && mountEl.textContent.trim().length) return;
        loadBookDescription(bookStr, mountEl);
      }catch(e){}
    }, delay);
  }catch(e){}
}
function scheduleDescriptionSweep(rootEl){
  try{
    const root = rootEl || document;
    if(!root) return;
    const runSweep = function(){
      try{
        const descEls = root.querySelectorAll('.book-desc[data-book]');
        descEls.forEach(function(el){
          try{
            const hasFull = el.dataset && el.dataset.full && String(el.dataset.full).trim().length;
            const hasText = el.textContent && el.textContent.trim().length;
            if(hasFull || hasText) return;
            const bk = el.getAttribute('data-book') || '';
            if(bk) loadBookDescription(bk, el);
          }catch(_){ }
        });
      }catch(e){}
    };
    setTimeout(runSweep, 3000);
    setTimeout(runSweep, 9000);
    setTimeout(runSweep, 20000);
  }catch(e){}
}
async function loadBookDescription(bookStr, mountEl){
  try{
    if(!mountEl) return;
    try{
      if(mountEl.__descLoadingTimer){ clearTimeout(mountEl.__descLoadingTimer); mountEl.__descLoadingTimer = null; }
      if((mountEl.textContent||'').trim() === 'Loading summary…'){ mountEl.textContent = ''; }
    }catch(e){}
    // Summary overrides from JSON
    try{
      await ensureSummaryOverridesLoaded();
      const override = getSummaryOverride(bookStr);
      if(override && String(override).trim().length){
        const full = String(override).trim();
        try{ if(mountEl.__descLoadingTimer){ clearTimeout(mountEl.__descLoadingTimer); mountEl.__descLoadingTimer = null; } }catch(e){}
        applyDescWithToggle(mountEl, full);
        try{
          localStorage.setItem('bookDesc:'+bookStr, JSON.stringify({text: full, at: Date.now()}));
          localStorage.setItem('bookDesc:'+normalizeBookKey(bookStr), JSON.stringify({text: full, at: Date.now()}));
        }catch(e){}
        return;
      }
    }catch(_){ }
    const key = 'bookDesc:'+bookStr;
    const nkey = 'bookDesc:'+normalizeBookKey(bookStr);
    // read-through cache
    let cached = null; let cachedAt = 0;
    try{
      const raw = localStorage.getItem(key) || localStorage.getItem(nkey);
      if(raw){ const obj = JSON.parse(raw); if(obj && obj.text){ cached=obj.text; cachedAt=obj.at||0; } }
    }catch(e){}
    const now = Date.now();
    if(cached && (now - cachedAt) < 1000*60*60*24*30){ // 30d
      try{ if(mountEl.__descLoadingTimer){ clearTimeout(mountEl.__descLoadingTimer); mountEl.__descLoadingTimer = null; } }catch(e){}
      applyDescWithToggle(mountEl, cached);
      return;
    }
    // Prepare holder and try Firestore-cached summary/description first (if hosted on Firebase)
    let fullText = '';
    try{
      const meta = await fetchBookMetaIfAvailable(bookStr);
      if(meta && meta.summary && String(meta.summary).trim().length){
        fullText = String(meta.summary).trim();
      } else if(meta && meta.description && String(meta.description).trim().length){
        fullText = toOneLiner(String(meta.description).trim());
      }
    }catch(_){ }
    // Do not generate summaries during voting.
    // At this point we rely on summary overrides + Firebase-cached bookMeta only.
    if(fullText && fullText.length){
      try{ if(mountEl.__descLoadingTimer){ clearTimeout(mountEl.__descLoadingTimer); mountEl.__descLoadingTimer = null; } }catch(e){}
      applyDescWithToggle(mountEl, fullText);
      try{
        localStorage.setItem(key, JSON.stringify({text: fullText, at: now}));
        localStorage.setItem(nkey, JSON.stringify({text: fullText, at: now}));
      }catch(e){}
    } else {
      // Keep a visible placeholder so users don't think the summary area is broken
      try{ if(mountEl.__descLoadingTimer){ clearTimeout(mountEl.__descLoadingTimer); mountEl.__descLoadingTimer = null; } }catch(e){}
      if(!mountEl.textContent || !mountEl.textContent.trim().length) mountEl.textContent = 'Summary unavailable.';
      scheduleDescriptionRetry(bookStr, mountEl);
    }
  }catch(e){
    try{ if(mountEl && mountEl.__descLoadingTimer){ clearTimeout(mountEl.__descLoadingTimer); mountEl.__descLoadingTimer = null; } }catch(_){ }
    try{ if(mountEl && (!mountEl.textContent || !mountEl.textContent.trim().length)) mountEl.textContent='Summary unavailable.'; }catch(_){}
  }
}

function normalizeBlurbText(s){
  try{
    const str = String(s||'');
    // Convert <br> to newlines, strip other tags
    const html = str.replace(/<br\s*\/?>(\r?\n)?/gi, '\n');
    const div = document.createElement('div');
    div.innerHTML = html;
    const text = div.textContent || div.innerText || '';
    // Clean stray markdown-style bold markers and normalize spaces
    return text
      .replace(/\u00A0/g,' ')
      .replace(/\*{2,}/g,'')
      .replace(/[ \t]+\n/g,'\n')
      .replace(/\s+$/,'');
  }catch(e){ return String(s||''); }
}
function applyDescWithToggle(mountEl, fullText){
  try{
    const fullRaw = String(fullText||'');
    const full = normalizeBlurbText(fullRaw).trim();
    if(!full){ mountEl.textContent=''; return; }
  const collapsed = trimToPreview(full, { maxChars: 320, maxSentences: 3 });
    const shouldCollapse = collapsed.length < full.length;
    mountEl.textContent = shouldCollapse ? collapsed : full;
    mountEl.dataset.full = full;
    mountEl.dataset.collapsed = collapsed;
    mountEl.dataset.expanded = shouldCollapse ? 'false' : 'true';
    if(shouldCollapse){ mountEl.classList.remove('expanded'); } else { mountEl.classList.add('expanded'); }
    // Setup toggle link only if there is more to show
    const meta = mountEl.closest('.book-meta');
    const links = meta ? meta.querySelector('.book-links') : null;
    if(links){
      let toggle = links.querySelector('.see-more');
      if(shouldCollapse){
        if(!toggle){
          toggle = document.createElement('a');
          toggle.href = '#';
          toggle.className = 'see-more';
          toggle.setAttribute('role','button');
          toggle.setAttribute('aria-expanded','false');
          toggle.textContent = 'See more';
          links.appendChild(toggle);
        } else {
          toggle.textContent = 'See more';
          toggle.setAttribute('aria-expanded','false');
          toggle.style.display = '';
        }
        // Bind click handler once per instance
        if(!toggle.__bound){
          toggle.addEventListener('click', function(ev){
            ev.preventDefault();
            const expanded = mountEl.dataset.expanded === 'true';
            if(expanded){
              mountEl.textContent = mountEl.dataset.collapsed || collapsed;
              mountEl.dataset.expanded = 'false';
              mountEl.classList.remove('expanded');
              toggle.textContent = 'See more';
              toggle.setAttribute('aria-expanded','false');
            } else {
              mountEl.textContent = mountEl.dataset.full || full;
              mountEl.dataset.expanded = 'true';
              mountEl.classList.add('expanded');
              toggle.textContent = 'See less';
              toggle.setAttribute('aria-expanded','true');
            }
          });
          toggle.__bound = true;
        }
      } else {
        if(toggle){ toggle.style.display = 'none'; }
      }
    }
  }catch(e){ try{ mountEl.textContent = fullText; }catch(_){} }
}

// Unified snapshot apply function so we can queue during boot
function __applyPollSnapshot(state){
  try{
    if(!state) return;
    try{ applyLiveSlotPreview(state.slotPreview || null); }catch(e){}
    // Respect ignore flag
    if(localStorage.getItem('viewerIgnoreServerPolls') || sessionStorage.getItem('viewerIgnoreServerPolls')){
      try{ debugBanner && (debugBanner.textContent = 'Viewer is ignoring server polls'); }catch(e){}
      return;
    }
    // Winner path
    if(state && state.winner && state.winner.book){
      const book = state.winner.book;
      const isNewWinner = window.__fbStateInited && window.__lastWinnerBook !== book;
      window.__celebrateWinnerNext = !!isNewWinner;
      window.__lastWinnerBook = book;
      try{ localStorage.setItem('pollWinner', JSON.stringify(state.winner)); }catch(e){}
      // Clear poll-only keys (don't clear winner)
  try{ window.__pollDiag ? __pollDiag.wrapRemove('pollChoices','applySnapshot-winner') : localStorage.removeItem('pollChoices'); }catch(e){}
  try{ window.__pollDiag ? __pollDiag.wrapRemove('pollPublishedAt','applySnapshot-winner') : localStorage.removeItem('pollPublishedAt'); }catch(e){}
      try{ renderWinner(book); }catch(e){}
      window.__fbStateInited = true;
      return;
    }
    // Runoff path
    if(state && state.runoff && state.runoff.active){
      const pcs = Array.isArray(state.runoff.choices) ? state.runoff.choices : [];
      try{ renderRunoff(pcs); }catch(e){}
      window.__fbStateInited = true;
      return;
    }
    // Normal poll
    const pcs = Array.isArray(state && state.pollChoices) ? state.pollChoices : [];
    const publishedAt = state && state.pollPublishedAt ? String(state.pollPublishedAt) : null;
    if(publishedAt && pcs.length >= 3){
      try{ localStorage.setItem('pollChoices', JSON.stringify(pcs)); }catch(e){}
      try{ localStorage.setItem('pollPublishedAt', publishedAt); }catch(e){}
      try{ const sid = window.__pollGuards && __pollGuards.computeSessionId(pcs, publishedAt); if(sid) localStorage.setItem('pollSessionId', sid); }catch(e){}
      try{ renderPollOrWaiting(); }catch(e){}
    } else {
      // Consider this a cleared poll (guarded)
      try{ if(window.__pollGuards){ __pollGuards.clearPoll('applySnapshot-empty'); } else { window.__pollDiag ? __pollDiag.wrapRemove('pollChoices','applySnapshot-empty') : localStorage.removeItem('pollChoices'); window.__pollDiag ? __pollDiag.wrapRemove('pollPublishedAt','applySnapshot-empty') : localStorage.removeItem('pollPublishedAt'); } }catch(e){}
      try{ renderPollOrWaiting(); }catch(e){}
    }
    window.__fbStateInited = true;
  }catch(e){ console.warn('[voting_poll] snapshot apply failed', e); }
}
(function(){
  try{
    if(window.fbSyncAvailable && typeof window.fbSubscribe === 'function'){
      window.fbSubscribe(function(state){
        try{
          console.log('[voting_poll] snapshot received', state);
          if(window.__viewerBlockApply){
            window.__queuedSnapshot = state;
            console.log('[voting_poll] snapshot queued (boot block)');
            return;
          }
          __applyPollSnapshot(state);
        }catch(e){ console.warn('[voting_poll] fbSubscribe handler error', e); }
      });
      console.log('[voting_poll] Firebase subscription active');
    } else {
      console.log('[voting_poll] Firebase not configured; viewer falls back to localStorage/storage events only');
    }
  }catch(e){ console.warn('[voting_poll] fb subscribe setup error', e); }
})();
// Default Goodreads resolver base to Firebase Functions if FIREBASE_CONFIG is present
(function(){
  try{
    if(!window.GOODREADS_RESOLVER_URL && !localStorage.getItem('grResolverBase')){
      const pid = window.FIREBASE_CONFIG && window.FIREBASE_CONFIG.projectId;
      if(pid){ window.GOODREADS_RESOLVER_URL = 'https://us-central1-' + pid + '.cloudfunctions.net/resolveGoodreads'; }
    }
  }catch(e){}
})();
// Helper to get normalized pollChoices from localStorage
function getPollChoices() {
  let pollChoicesRaw = JSON.parse(localStorage.getItem('pollChoices') || '[]') || [];
  // Normalize possible legacy shapes and filter out empty titles
  let pollChoices = [];
  if (Array.isArray(pollChoicesRaw) && pollChoicesRaw.length){
    pollChoices = pollChoicesRaw.map(item => {
      if (!item) return null;
      const book = item.book || item.display || item.title || item[0] || '';
      const name = item.name || item.suggestedBy || item[1] || '';
      return { book: String(book).trim(), name: String(name).trim() };
    }).filter(x => x && x.book && x.book.length > 0);
  }
  return pollChoices;
}

// Helpers for safe DOM keys
function slugifyId(text){
  try{ return ('voters-'+String(text||'')).toLowerCase().replace(/[^a-z0-9]+/g,'-').replace(/^-+|-+$/g,''); }catch(e){ return 'voters-unknown'; }
}
function htmlEscape(s){ try{ return String(s||'').replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;'); }catch(e){ return String(s||''); } }

(function(){
  try{
    if(window.fbSyncAvailable && typeof window.fbSubscribe === 'function'){
      window.fbSubscribe(function(state){
        try{
          // Respect viewer ignore flag: don't apply remote state
          if(localStorage.getItem('viewerIgnoreServerPolls') || sessionStorage.getItem('viewerIgnoreServerPolls')){
            try{ debugBanner && (debugBanner.textContent = 'Viewer is ignoring server polls'); }catch(e){}
            return;
          }
          try{ applyLiveSlotPreview(state && state.slotPreview ? state.slotPreview : null); }catch(e){}
          // Apply winner first; if set, it should override any active runoff UI
          if(state && state.winner && state.winner.book){
            const book = state.winner.book;
            // Celebrate only if this winner is newly observed after initial snapshot
            const isNewWinner = window.__fbStateInited && window.__lastWinnerBook !== book;
            window.__celebrateWinnerNext = !!isNewWinner;
            window.__lastWinnerBook = book;
            try{ localStorage.setItem('pollWinner', JSON.stringify(state.winner)); }catch(e){}
            try{ window.__pollDiag ? __pollDiag.wrapRemove('pollChoices','subscribe-winner') : localStorage.removeItem('pollChoices'); }catch(e){}
            try{ window.__pollDiag ? __pollDiag.wrapRemove('pollPublishedAt','subscribe-winner') : localStorage.removeItem('pollPublishedAt'); }catch(e){}
            try{ renderWinner(book); }catch(e){}
            // Stop any runoff listeners when a winner is announced
            try{ if(window.__unsubRunoffVotes){ window.__unsubRunoffVotes(); window.__unsubRunoffVotes = null; } }catch(e){}
            window.__fbStateInited = true;
            return;
          }
          // If a tiebreaker runoff is active, render it and return
          if(state && state.runoff && state.runoff.active){
            const pcs = Array.isArray(state.runoff.choices) ? state.runoff.choices : [];
            try{ renderRunoff(pcs); }catch(e){}
            window.__fbStateInited = true;
            return;
          }
          // No winner — apply poll state
          const pcs = Array.isArray(state && state.pollChoices) ? state.pollChoices : [];
          // Ensure any runoff listener is removed when showing normal poll
          try{ if(window.__unsubRunoffVotes){ window.__unsubRunoffVotes(); window.__unsubRunoffVotes = null; } }catch(e){}
          const publishedAt = state && state.pollPublishedAt ? String(state.pollPublishedAt) : null;
          if(publishedAt && pcs.length >= 3){
            try{ localStorage.setItem('pollChoices', JSON.stringify(pcs)); }catch(e){}
            try{ localStorage.setItem('pollPublishedAt', publishedAt); }catch(e){}
            try{ const sid = window.__pollGuards && __pollGuards.computeSessionId(pcs, publishedAt); if(sid) localStorage.setItem('pollSessionId', sid); }catch(e){}
            try{ renderPollOrWaiting(); }catch(e){}
          } else {
            // Clear poll locally (guarded)
            try{ if(window.__pollGuards){ __pollGuards.clearPoll('subscribe-empty'); } else { window.__pollDiag ? __pollDiag.wrapRemove('pollChoices','subscribe-empty') : localStorage.removeItem('pollChoices'); window.__pollDiag ? __pollDiag.wrapRemove('pollPublishedAt','subscribe-empty') : localStorage.removeItem('pollPublishedAt'); } }catch(e){}
            try{ renderPollOrWaiting(); }catch(e){}
          }
          window.__fbStateInited = true;
        }catch(e){ console.warn('[voting_poll] fbSubscribe apply failed', e); }
      });
      try{ console.log('[voting_poll] Firebase subscription active'); }catch(e){}
    } else {
      try{ console.log('[voting_poll] Firebase not configured; viewer falls back to localStorage/storage events only'); }catch(e){}
    }
  }catch(e){ console.warn('[voting_poll] fb subscribe setup error', e); }
})();
// (duplicate getPollChoices removed)

  let votes = JSON.parse(localStorage.getItem("votes")) || {}; // Load votes
  const pollOptions = document.getElementById("poll-options");
  function setPollOptionsVisible(visible){ try{ if(!pollOptions) return; pollOptions.style.display = visible ? '' : 'none'; }catch(e){} }
  let pollVisible = false;
  const nameInput = document.getElementById("nameInput");
  const submitNameBtn = document.getElementById("submitNameBtn");
  const editNameBtn = document.getElementById("editNameBtn");
  let voterName = "";
  let viewerHasEnteredNameFlow = false; // becomes true after user clicks "Enter your name" or has saved name
  // Clear/Accept controls removed from finished viewer UI (defensive behavior enforced instead)
  // small debug banner to show raw pollChoices (helpful during troubleshooting)
  let debugBanner = document.getElementById('poll-debug-banner');
  if(!debugBanner){
    try{
      debugBanner = document.createElement('div');
      debugBanner.style.marginTop='8px'; debugBanner.style.fontSize='0.9rem'; debugBanner.style.color='#666';
      debugBanner.id='poll-debug-banner';
      const _ps = document.getElementById('poll-status');
      if(_ps) _ps.appendChild(debugBanner);
    }catch(e){ /* ignore if DOM not ready */ }
  }

  // Early migration: if an older session set the sessionStorage ignore flag, persist it to localStorage
  try{
    if(sessionStorage.getItem('viewerIgnoreServerPolls') && !localStorage.getItem('viewerIgnoreServerPolls')){
      try{ localStorage.setItem('viewerIgnoreServerPolls','1'); console.log('[voting_poll] migrated viewerIgnoreServerPolls from sessionStorage -> localStorage (early)'); }catch(e){}
    }
  }catch(e){}

  // Helper to determine if the viewer is ignoring server polls (accept either old session flag or new persistent local flag)
  function viewerIsIgnoring(){ try{ return !!(localStorage.getItem('viewerIgnoreServerPolls') || sessionStorage.getItem('viewerIgnoreServerPolls')); }catch(e){ return false; } }

  function setNameControlsVisible(visible){
    try{
      const flow = document.getElementById('name-flow');
      const na = document.querySelector('.name-actions');
      if(flow) flow.style.display = visible ? '' : 'none';
      if(na) na.style.display = visible ? 'flex' : 'none';
      try{ syncNamePanelMode(); }catch(e){}
    }catch(e){}
  }
  function syncNamePanelMode(){
    try{
      const flow = document.getElementById('name-flow');
      if(!flow || !nameInput) return;
      const saved = !!(nameInput.disabled && String(nameInput.value||'').trim().length);
      flow.classList.toggle('name-saved', saved);
    }catch(e){}
  }
  function applyNameCompactState(compact){
    try{
      const flow = document.getElementById('name-flow');
      if(!flow) return;
      flow.classList.toggle('compact', !!compact);
    }catch(e){}
  }
  // Initialize name UI based on saved state; used even when poll hasn't been published yet
  function initNameControlsFromSaved(){
    try{
      setNameControlsVisible(true);
      const saved = localStorage.getItem('voterName');
      if(saved && saved.length){
        voterName = saved;
        if(nameInput){ nameInput.value = saved; nameInput.disabled = true; }
        if(submitNameBtn) submitNameBtn.style.display='none';
        if(editNameBtn) editNameBtn.style.display='inline-block';
        try{ const nt = document.querySelector('.name-title'); if(nt){ nt.textContent = ''; } }catch(e){}
        try{ applyNameCompactState(true); }catch(e){}
        try{ syncNamePanelMode(); }catch(e){}
        // If poll exists later, make sure it's not dimmed
        try{ if(pollOptions) pollOptions.classList.remove('poll-needs-name'); }catch(e){}
        // Treat saved name as already entered so we skip the prompt when poll is published
        viewerHasEnteredNameFlow = true;
      } else {
        // No saved name — allow entering now (ahead of poll publish)
        if(nameInput){ nameInput.disabled = false; }
        if(submitNameBtn) submitNameBtn.style.display='inline-block';
        if(editNameBtn) editNameBtn.style.display='none';
        try{ const nt = document.querySelector('.name-title'); if(nt){ nt.textContent = 'Enter your name to join the vote'; } }catch(e){}
        try{ applyNameCompactState(false); }catch(e){}
        try{ syncNamePanelMode(); }catch(e){}
        // Keep viewerHasEnteredNameFlow as-is (false) until they submit
      }
    }catch(e){}
  }
  // Hide just the name entry/edit UI after a winner is announced (issue #31)
  function hideNameControlsAfterWinner(){
    try{
      const flow = document.getElementById('name-flow');
      const ni = document.getElementById('nameInput');
      const submitBtn = document.getElementById('submitNameBtn');
      const editBtn = document.getElementById('editNameBtn');
      if(flow) flow.style.display = 'none';
      if(ni){ ni.blur(); }
      if(submitBtn) submitBtn.style.display='none';
      if(editBtn) editBtn.style.display='none';
    }catch(e){}
  }

  function showPollEntryPrompt(){
    try{
      const p = document.getElementById('poll-ready');
      console.log('[voting_poll] showPollEntryPrompt called, element?', !!p);
      if(!p) return;
      // Build content depending on whether a saved voterName exists
      const saved = localStorage.getItem('voterName');
      if(saved && saved.trim().length){
        p.innerHTML = `
          <div class="card shadow-sm prompt-card">
            <div style="font-weight:600; margin-bottom:8px;">The poll is ready!</div>
            <div class="small text-muted" style="margin-bottom:10px;">Continue as <strong>${String(saved).replace(/</g,'&lt;')}</strong> or use a different name.</div>
            <div class="prompt-actions"><button id="continueAsSavedBtn" class="btn cta-primary">Continue as ${String(saved).replace(/</g,'&lt;')}</button><button id="enterNameBtn" class="btn btn-outline-secondary">Use a different name</button></div>
          </div>`;
        // ensure visible and hide any waiting UI so the prompt replaces it
        p.classList.remove('d-none'); p.style.display=''; p.style.visibility='visible'; p.style.opacity=0; p.style.transform='translateY(6px)';
        try{ const statusEl = document.getElementById('poll-status'); if(statusEl){ statusEl.innerHTML = ''; statusEl.style.display = 'none'; } }catch(e){}
        // animate in
        requestAnimationFrame(()=>{ p.style.transition='opacity 320ms ease, transform 320ms ease'; p.style.opacity=1; p.style.transform='translateY(0)'; });
        // Wire buttons after render
        setTimeout(()=>{
          try{ const c = document.getElementById('continueAsSavedBtn'); if(c) c.addEventListener('click', acceptSavedName); }catch(e){}
          try{ const ebtn = document.getElementById('enterNameBtn'); if(ebtn) ebtn.addEventListener('click', beginNameFlow); }catch(e){}
        },40);
      } else {
        p.innerHTML = `
          <div class="card shadow-sm prompt-card">
            <div style="font-weight:600; margin-bottom:8px;">The poll is ready!</div>
            <div class="small text-muted" style="margin-bottom:10px;">Enter your name to begin voting.</div>
            <div class="prompt-actions"><button id="enterNameBtn" class="btn cta-primary">Enter your name to begin</button></div>
          </div>`;
        p.classList.remove('d-none'); p.style.display=''; p.style.visibility='visible'; p.style.opacity=0; p.style.transform='translateY(6px)';
        try{ const statusEl = document.getElementById('poll-status'); if(statusEl){ statusEl.innerHTML = ''; statusEl.style.display = 'none'; } }catch(e){}
        requestAnimationFrame(()=>{ p.style.transition='opacity 320ms ease, transform 320ms ease'; p.style.opacity=1; p.style.transform='translateY(0)'; });
        setTimeout(()=>{ try{ const enterBtn = document.getElementById('enterNameBtn'); if(enterBtn) enterBtn.addEventListener('click', beginNameFlow); }catch(e){} },40);
      }
      try{ updateDebugBanner(); }catch(e){}
    }catch(e){ console.warn('[voting_poll] showPollEntryPrompt error', e); }
  }
  function hidePollEntryPrompt(){ try{ const p = document.getElementById('poll-ready'); console.log('[voting_poll] hidePollEntryPrompt called, element?', !!p); if(!p) return; // animate out then hide
    try{ p.style.transition='opacity 220ms ease, transform 220ms ease'; p.style.opacity=0; p.style.transform='translateY(-6px)'; }catch(e){}
    setTimeout(()=>{ try{ p.classList.add('d-none'); p.style.display = 'none'; p.style.visibility = 'hidden'; try{ restoreWaitingArea(); }catch(e){} }catch(e){} }, 260);
    try{ updateDebugBanner(); }catch(e){} }catch(e){ console.warn('[voting_poll] hidePollEntryPrompt error', e); } }

  // When hiding the prompt, restore the status area so waiting messages can appear later
  function restoreWaitingArea(){ try{ const statusEl = document.getElementById('poll-status'); if(statusEl){ statusEl.style.display = ''; } }catch(e){} }

  function beginNameFlow(){ try{ console.log('[voting_poll] beginNameFlow called'); viewerHasEnteredNameFlow = true; // ensure prompt hidden via both class and inline style
      // animate prompt out then show name controls
      try{ const p = document.getElementById('poll-ready'); if(p){ p.style.transition='opacity 220ms ease, transform 220ms ease'; p.style.opacity = 0; p.style.transform='translateY(-6px)'; } }catch(e){}
      setTimeout(()=>{
        try{ hidePollEntryPrompt(); setNameControlsVisible(true); if(nameInput){ nameInput.style.display='block'; nameInput.focus(); } }catch(e){}
        // dim the poll area until name submitted
        try{ if(pollOptions) pollOptions.classList.add('poll-needs-name'); }catch(e){}
        // render after showing controls so checkboxes are wired
        try{ renderPollOrWaiting(); }catch(e){}
        try{ updateDebugBanner(); }catch(e){}
      }, 260);
    }catch(e){ console.warn('[voting_poll] beginNameFlow error', e); } }

  function acceptSavedName(){
    try{
      const saved = localStorage.getItem('voterName');
      if(!saved) return beginNameFlow();
      console.log('[voting_poll] acceptSavedName called, saved=', saved);
      viewerHasEnteredNameFlow = true;
      // animate prompt out then apply saved name state
      try{ const p = document.getElementById('poll-ready'); if(p){ p.style.transition='opacity 220ms ease, transform 220ms ease'; p.style.opacity=0; p.style.transform='translateY(-6px)'; } }catch(e){}
      setTimeout(()=>{
        try{
          // Populate UI with saved name and mark as submitted
          voterName = saved;
          if(nameInput){ nameInput.value = saved; nameInput.disabled = true; }
          try{ submitNameBtn.style.display = 'none'; editNameBtn.style.display = 'inline-block'; }catch(e){}
          try{ const nt = document.querySelector('.name-title'); if(nt){ nt.textContent = `You're voting as ${saved}`; } }catch(e){}
          try{ if(pollOptions) pollOptions.classList.remove('poll-needs-name'); }catch(e){}
          hidePollEntryPrompt(); setNameControlsVisible(true);
          try{ renderPollOrWaiting(); }catch(e){}
          try{ updateDebugBanner(); }catch(e){}
        }catch(e){ console.warn('[voting_poll] acceptSavedName inner error', e); }
      }, 260);
    }catch(e){ console.warn('[voting_poll] acceptSavedName error', e); }
  }

  // viewerHasAccepted removed; finished viewer will not show Accept/Clear controls

  // Display poll options or waiting UI
  function renderPollOrWaiting() {
    try{ renderLiveSlotPreview(); }catch(e){}
    if(isLiveSlotPreviewActive()){
      try{ hidePollEntryPrompt(); }catch(e){}
      try{ setNameControlsVisible(false); }catch(e){}
      showWaitingMessage('Wait until the lead has randomly chosen all three books with the slot machine.');
      return;
    }
    // If viewer has chosen to ignore server polls (session or persisted), do not render any stored pollChoices
    try{
        const _ign = !!(localStorage.getItem('viewerIgnoreServerPolls') || sessionStorage.getItem('viewerIgnoreServerPolls'));
        console.log('[voting_poll] viewerIsIgnoring?', _ign, 'local:', localStorage.getItem('viewerIgnoreServerPolls'), 'session:', sessionStorage.getItem('viewerIgnoreServerPolls'));
        if(_ign){
          try{ debugBanner.textContent = 'Viewer is ignoring server polls'; }catch(e){}
          setPollOptionsVisible(false);
    showWaitingMessage('Wait until the lead has randomly chosen all three books with the slot machine.');
    // Allow entering name ahead of time even while waiting/ignoring
  try{ initNameControlsFromSaved(); }catch(e){}
      return;
        }
    // Defensive: finished viewers must not render persisted pollChoices; allow render to continue only if pollChoices are present and were written in this session
    // (We already removed persisted pollChoices on load.)
    }catch(e){}
    const pollChoices = getPollChoices();
    // Only render a poll if admin explicitly published it (pollPublishedAt set)
    try{ 
      const publishedAt = localStorage.getItem('pollPublishedAt'); 
      const savedName = (localStorage.getItem('voterName')||'').trim();
      if(!publishedAt){ 
        // Poll not started yet: always show waiting view (Merc or live slot preview), never name entry
        setPollOptionsVisible(false);
        showWaitingMessage('Wait until the lead has randomly chosen all three books with the slot machine.');
        return;
      } 
    }catch(e){}
    // If the poll is published, require a submitted name before showing any poll UI
    try{
      const saved = (localStorage.getItem('voterName')||'').trim();
      const publishedAtDebug = localStorage.getItem('pollPublishedAt');
      console.log('[voting_poll] name gating:', 'savedName=', saved ? 'yes' : 'no', 'publishedAt=', publishedAtDebug);
      if(!saved){
        // Force name entry view only
        try{ hidePollEntryPrompt(); }catch(e){}
        try{ setPollOptionsVisible(false); }catch(e){}
        try{ const ro = document.getElementById('runoff-options'); if(ro){ ro.style.display='none'; ro.innerHTML=''; } }catch(e){}
        try{ const status = document.getElementById('poll-status'); if(status){ status.innerHTML=''; } }catch(e){}
        try{ setNameControlsVisible(true); if(nameInput){ nameInput.disabled=false; nameInput.focus(); } if(submitNameBtn){ submitNameBtn.style.display='inline-block'; } if(editNameBtn){ editNameBtn.style.display='none'; } }catch(e){}
        // Ensure the poll area remains dimmed/inactive until name is submitted
        try{ if(pollOptions) pollOptions.classList.add('poll-needs-name'); }catch(e){}
        return;
      } else {
        // We have a saved name: hide any prompt and proceed
        try{ hidePollEntryPrompt(); }catch(e){}
      }
    }catch(e){}
  // (name already required above)
    console.log('[voting_poll] renderPollOrWaiting pollChoices:', pollChoices);
    if (!Array.isArray(pollChoices) || pollChoices.length < 3) {
      // Defensive: if stored pollChoices are present but malformed, clear them so viewers show waiting UI
      try{ const raw = JSON.parse(localStorage.getItem('pollChoices') || 'null'); if(Array.isArray(raw) && raw.length > 0 && (!Array.isArray(pollChoices) || pollChoices.length < 3)){ localStorage.removeItem('pollChoices'); } }catch(e){}
      setPollOptionsVisible(false);
      showWaitingMessage('Wait until the lead has randomly chosen all three books with the slot machine.');
      return;
    }
    // Hide waiting UI when showing poll
    const status = document.getElementById('poll-status');
    if(status) status.innerHTML = '';
    pollOptions.innerHTML = "";
    setPollOptionsVisible(true);
    // Reveal name controls when poll is visible
    try{ setNameControlsVisible(true); }catch(e){}
    // Restore voterName from session if present (only when poll is visible)
      // Restore voterName from localStorage if present (only when poll is visible)
      try{
        const saved = localStorage.getItem('voterName');
        if(saved && saved.length){
          voterName = saved;
          if(nameInput) nameInput.value = saved;
          try{ nameInput.disabled = true; submitNameBtn.style.display='none'; editNameBtn.style.display='inline-block'; }catch(e){}
          try{ if(pollOptions) pollOptions.classList.remove('poll-needs-name'); }catch(e){}
        } else {
          // No name present: autofocus the name input and dim the poll area
          try{ if(nameInput) nameInput.focus(); if(pollOptions) pollOptions.classList.add('poll-needs-name'); }catch(e){}
        }
      }catch(e){}
    pollChoices.forEach((choice, index) => {
      const option = document.createElement("div");
      option.className = "poll-item";
      const _book = String(choice.book||'');
      const _bookDisplay = formatBookDisplayTitle(_book);
      const _name = String(choice.name||'');
      const votersId = slugifyId(_book);
      option.innerHTML = `
        <div class="vote-container">
          <input type="checkbox" id="choice${index}" name="poll" value="${htmlEscape(_book)}">
          <label for="choice${index}" class="vote-label">Vote</label>
        </div>
        <div class="poll-content">
          <label for="choice${index}">${htmlEscape(_bookDisplay)}</label>
          <div class="suggested-by">Suggested by ${htmlEscape(_name)}</div>
          <div class="book-meta" aria-live="polite">
            <div class="book-desc" data-book="${htmlEscape(_book)}"></div>
            <div class="book-links">
              <a class="btn btn-sm btn-outline-secondary goodreads-link" data-book="${htmlEscape(_book)}" href="${buildGoodreadsUrl(_book)}" target="_blank" rel="noopener noreferrer" aria-label="View ${htmlEscape(_bookDisplay)} on Goodreads">Goodreads</a>
            </div>
          </div>
          <div class="voters" id="${votersId}" data-book="${htmlEscape(_book)}">Voted by: ${getVoters(_book)}</div>
          <div class="vote-total" data-book="${htmlEscape(_book)}">Total Votes: ${(Array.isArray(votes[_book])?votes[_book].length:0)}</div>
        </div>
      `;
      pollOptions.appendChild(option);
      // Wire up checkbox state according to current voterName and votes
      const checkbox = option.querySelector("input[type='checkbox']");
      const voteLabel = option.querySelector('.vote-label');
      checkbox.disabled = !voterName;
      try{ checkbox.checked = isUserVoted(choice.book); }catch(e){}
      if(voterName){ voteLabel.classList.add('bold'); } else { voteLabel.classList.remove('bold'); }
      checkbox.addEventListener("change", () => toggleVote(choice.book));
      // Initialize total votes label from current votes map
      try{ updateVoteCount(choice.book); }catch(e){}
  // Load book description asynchronously
  try{ const descEl = option.querySelector('.book-desc[data-book]'); if(descEl){ loadBookDescription(_book, descEl); } }catch(e){}
  // Resolve Goodreads deep link asynchronously
  try{ const links = option.querySelector('.book-links'); if(links){ resolveAndApplyGoodreads(_book, links); } }catch(e){}
    });
    // Add multi-select caption at top (not shown in runoff or winner states)
    try {
      const existingCaption = document.getElementById('multi-choice-caption');
      if(existingCaption) existingCaption.remove();
      const winner = localStorage.getItem('pollWinner');
      const runoffActive = !!document.getElementById('runoff-options') && document.getElementById('runoff-options').style.display !== 'none';
      if(!winner && !runoffActive){
        const cap = document.createElement('div');
        cap.id = 'multi-choice-caption';
        cap.className = 'text-muted small poll-top-row';
  cap.style.fontSize = '0.75rem';
  cap.style.marginTop = '12px'; // a bit more breathing room now that border removed
  cap.style.marginBottom = '6px';
  cap.style.paddingTop = '0';
  cap.style.fontWeight = '400';
        const left = document.createElement('span');
        left.textContent = 'Multiple choices allowed';
        cap.appendChild(left);

        const savedNameForInline = (localStorage.getItem('voterName')||'').trim();
        if(savedNameForInline){
          const inlineEditBtn = document.createElement('button');
          inlineEditBtn.type = 'button';
          inlineEditBtn.className = 'main-page-btn inline-edit-name-btn';
          inlineEditBtn.textContent = 'Edit Name';
          inlineEditBtn.addEventListener('click', ()=>{ try{ editName(); }catch(e){} });
          cap.appendChild(inlineEditBtn);
          try{ setNameControlsVisible(false); }catch(e){}
        }
        // Insert before first poll item (top of list)
        if(pollOptions.firstChild){
          pollOptions.insertBefore(cap, pollOptions.firstChild);
        } else {
          pollOptions.appendChild(cap);
        }
      }
    } catch(e){}
    setPollOptionsVisible(true);
    try{ updateDebugBanner(); }catch(e){}
    // Prewarm covers for current poll choices (quietly), so winner is instant
    try{ schedulePrewarmPollCovers(); }catch(e){}
    // Sweep any missing descriptions after render (handles delayed resolver availability)
    try{
      const sid = localStorage.getItem('pollSessionId') || '';
      const lastSid = pollOptions && pollOptions.dataset ? (pollOptions.dataset.descSweepSession||'') : '';
      if(pollOptions && pollOptions.dataset && sid !== lastSid){
        pollOptions.dataset.descSweepSession = sid;
        scheduleDescriptionSweep(pollOptions);
      } else if(pollOptions){
        scheduleDescriptionSweep(pollOptions);
      }
    }catch(e){}
  }

  function isUserVoted(book) {
    return votes[book]?.includes(voterName);
  }
  function getVoters(book) {
    return votes[book]?.join(", ") || "No votes yet";
  }
  function toggleVote(book) {
    if (!voterName) {
      alert("Please submit your name before voting!");
      return;
    }
    if (!votes[book]) votes[book] = [];
    if (isUserVoted(book)) {
      votes[book] = votes[book].filter(voter => voter !== voterName);
    } else {
      votes[book].push(voterName);
    }
    localStorage.setItem("votes", JSON.stringify(votes));
    updateVoters(book);
    // Sync this voter's selections to Firestore (cross-device updates)
  try{
      if(window.fbSyncAvailable && typeof window.fbSetVotes === 'function'){
        const books = Object.keys(votes).filter(b=> Array.isArray(votes[b]) && votes[b].includes(voterName));
    window.fbSetVotes(voterName, books);
    try{ console.log('[voting_poll] synced votes for', voterName, books); }catch(e){}
      }
    }catch(e){}
  }
  function updateVoters(book) {
    let votersDiv = document.getElementById(slugifyId(book));
    if(!votersDiv){
      try{
        const all = document.querySelectorAll('.voters[data-book]');
        for(const el of all){ if((el.getAttribute('data-book')||'') === String(book)){ votersDiv = el; break; } }
      }catch(e){}
    }
    if (votersDiv) votersDiv.innerHTML = `Voted by: ${getVoters(book)}`;
  // Also update the total votes label
  try{ updateVoteCount(book); }catch(e){}
    // Update the "Total Votes" label below the voters list (poll view)
    try{
      let totalEl = null;
      try{
        const all = document.querySelectorAll('#poll-options .vote-total[data-book]');
        for(const el of all){ if((el.getAttribute('data-book')||'') === String(book)){ totalEl = el; break; } }
      }catch(e){}
      if(totalEl){ const count = Array.isArray(votes[book]) ? votes[book].length : 0; totalEl.textContent = 'Total Votes: ' + count; }
    }catch(e){}
    try{
      let checkbox = null;
      try{
        const allCbs = document.querySelectorAll("input[type='checkbox'][name='poll']");
        for(const cb of allCbs){ if(cb && cb.value === String(book)){ checkbox = cb; break; } }
      }catch(e){}
      const voteLabel = checkbox ? checkbox.parentElement.querySelector('.vote-label') : null;
      if(checkbox){ checkbox.checked = isUserVoted(book); checkbox.disabled = !voterName; }
      if(voteLabel){ if(voterName) voteLabel.classList.add('bold'); else voteLabel.classList.remove('bold'); }
    }catch(e){}
  }
  // Update the Total Votes label for a given book (regular poll)
  function updateVoteCount(book){
    try{
      const count = Array.isArray(votes[book]) ? votes[book].length : 0;
      // Mirror into the Total Votes label under the voters list
      try{
        let totalEl = null; const allTotals = document.querySelectorAll('#poll-options .vote-total[data-book]');
        for(const el of allTotals){ if((el.getAttribute('data-book')||'') === String(book)){ totalEl = el; break; } }
        if(totalEl){ totalEl.textContent = 'Total Votes: ' + count; }
      }catch(e){}
    }catch(e){}
  }
  function submitName() {
    const name = nameInput.value.trim();
    if (!name) {
      try{ nameInput.classList.add('is-invalid'); const err = document.getElementById('nameError'); if(err){ err.textContent='Please enter your name.'; err.classList.add('show'); } }catch(e){}
      try{ nameInput.focus(); nameInput.select && nameInput.select(); }catch(e){}
      return;
    }
    try{ nameInput.classList.remove('is-invalid'); const err = document.getElementById('nameError'); if(err) err.classList.remove('show'); }catch(e){}
    voterName = name;
    nameInput.disabled = true;
    nameInput.style.width = `${name.length + 2}ch`;
  submitNameBtn.style.display = "none";
  editNameBtn.style.display = "inline-block";
    try{ const nt = document.querySelector('.name-title'); if(nt){ nt.textContent = ''; } }catch(e){}
    try{ applyNameCompactState(true); }catch(e){}
    try{ syncNamePanelMode(); }catch(e){}
    try{ sessionStorage.setItem('voterName', voterName); }catch(e){}

      const checkboxes = document.querySelectorAll('input[type="checkbox"]');
      try{ localStorage.setItem('voterName', voterName); }catch(e){}
    const labels = document.querySelectorAll('.vote-label');
    checkboxes.forEach(checkbox => checkbox.disabled = false);
    labels.forEach(label => label.classList.add('bold'));
    // Undim and re-enable poll interactions now that a name is submitted
  try{ if(pollOptions) pollOptions.classList.remove('poll-needs-name'); }catch(e){}
  try{ const ro = document.getElementById('runoff-options'); if(ro) ro.classList.remove('poll-needs-name'); }catch(e){}
  // Subtle feedback: trigger the same single fade-in used by Merc (no fade-out)
  try{ const panel = document.querySelector('.name-panel'); if(panel){ panel.classList.remove('fade-in'); void panel.offsetWidth; panel.classList.add('fade-in'); } }catch(e){}
  // Render waiting or poll UI immediately after name submit
  try{ renderPollOrWaiting(); }catch(e){}
  // After name is set, push current selections (if any) so other devices reflect them
  try{
    if(window.fbSyncAvailable && typeof window.fbSetVotes === 'function'){
      const books = Object.keys(votes).filter(b=> Array.isArray(votes[b]) && votes[b].includes(voterName));
      window.fbSetVotes(voterName, books);
    }
  }catch(e){}
  // Also enable any runoff radio inputs now that we have a name
  try{
    const ro = document.getElementById('runoff-options');
    if(ro){
      Array.from(ro.querySelectorAll('input[type="radio"][name="runoff"]')).forEach(r=> r.disabled = false);
    }
  }catch(e){}
  // Late join enhancement: if user submits name after poll already began, reveal poll with fade-in
  try{ lateJoinRevealIfPollActive(); }catch(e){}
  // Shift focus to first actionable control (checkbox) or status region for accessibility
  try{
    const cb = document.querySelector('#poll-options input[type="checkbox"]');
    if(cb){ cb.focus(); }
    else {
      const st = document.getElementById('poll-status'); if(st){ st.setAttribute('tabindex','-1'); st.focus(); setTimeout(()=> st.removeAttribute('tabindex'), 1000); }
    }
  }catch(e){}
  }
  function editName() {
    nameInput.disabled = false;
    nameInput.style.width = "70%";
    submitNameBtn.style.display = "inline-block";
    editNameBtn.style.display = "none";
    voterName = "";
  try{ const nt = document.querySelector('.name-title'); if(nt){ nt.textContent = 'Enter your name to join the vote'; } }catch(e){}
  try{ applyNameCompactState(false); }catch(e){}
  try{ syncNamePanelMode(); }catch(e){}
  // Trigger the same single fade-in used by Merc when entering edit mode
  try{ const panel = document.querySelector('.name-panel'); if(panel){ panel.classList.remove('fade-in'); void panel.offsetWidth; panel.classList.add('fade-in'); } }catch(e){}
    try{ localStorage.removeItem('voterName'); }catch(e){}
    const checkboxes = document.querySelectorAll('input[type="checkbox"]');
    const labels = document.querySelectorAll('.vote-label');
    checkboxes.forEach(checkbox => checkbox.disabled = true);
    labels.forEach(label => label.classList.remove('bold'));
  // Hide poll and runoff entirely until a new name is submitted
  try{ setPollOptionsVisible(false); }catch(e){}
  try{ const ro = document.getElementById('runoff-options'); if(ro){ ro.style.display='none'; ro.innerHTML=''; } }catch(e){}
  try{ const status = document.getElementById('poll-status'); if(status){ status.innerHTML=''; } }catch(e){}
  try{ setNameControlsVisible(true); if(nameInput){ nameInput.focus(); } }catch(e){}
  }
  submitNameBtn.addEventListener("click", submitName);
  editNameBtn.addEventListener("click", editName);
  // Allow pressing Enter in the name field to submit; also hide poll when input becomes empty
  try{ if(nameInput){
    nameInput.addEventListener('keydown', function(ev){ if(ev.key === 'Enter'){ ev.preventDefault(); submitName(); } });
    nameInput.addEventListener('input', function(){
      try{
        const publishedAt = localStorage.getItem('pollPublishedAt');
        const v = (nameInput.value||'').trim();
        if(publishedAt && v.length === 0){
          // Treat as no name: hide poll and runoff
          setPollOptionsVisible(false);
          const ro = document.getElementById('runoff-options'); if(ro){ ro.style.display='none'; ro.innerHTML=''; }
        }
      }catch(e){}
    });
  } }catch(e){}

  // Initial render on page load
  renderPollOrWaiting();

  // Helper: when a viewer arrives after poll start and only now submits a name, force-paint poll immediately
  function lateJoinRevealIfPollActive(){
    try{
      const publishedAt = localStorage.getItem('pollPublishedAt');
      const winnerRaw = localStorage.getItem('pollWinner');
      if(winnerRaw){
        try{ const w = JSON.parse(winnerRaw); if(w && w.book){ renderWinner(w.book); return; } }catch(e){}
      }
      if(!publishedAt) return; // no active poll
      const choicesRaw = localStorage.getItem('pollChoices');
      if(choicesRaw){
        // Ensure poll options container visible with fade-in
        try{
          if(pollOptions){
            setPollOptionsVisible(true);
            pollOptions.classList.remove('fade-in');
            // Trigger reflow hack then add fade-in
            void pollOptions.offsetWidth;
            pollOptions.classList.add('fade-in');
          }
        }catch(e){}
        try{ renderPollOrWaiting(); }catch(e){}
      } else {
        // Race: pollChoices not yet in localStorage; run staged retries
        let attempts = 0;
        const schedule = [120, 350, 800, 1500];
        const statusElId = 'late-join-status';
        try{
          let st = document.getElementById(statusElId);
          if(!st){
            st = document.createElement('div');
            st.id = statusElId;
            st.style.fontSize='0.8rem'; st.style.color='#555'; st.style.margin='6px 0 4px';
            st.textContent = 'Loading current poll…';
            const ps = document.getElementById('poll-status'); if(ps) ps.appendChild(st);
          } else { st.textContent = 'Loading current poll…'; }
        }catch(e){}
        function tryLoad(){
          const again = localStorage.getItem('pollChoices');
            if(again){
              try{ const st = document.getElementById(statusElId); if(st) st.textContent=''; }catch(e){}
              try{ setPollOptionsVisible(true); if(pollOptions){ pollOptions.classList.add('fade-in'); } }catch(e){}
              try{ renderPollOrWaiting(); }catch(e){}
              console.log('[late-join] success after attempt', attempts);
              return;
            }
            if(attempts < schedule.length){
              const delay = schedule[attempts++];
              console.log('[late-join] retry in', delay,'ms');
              setTimeout(tryLoad, delay);
            } else {
              console.warn('[late-join] pollChoices still missing after retries');
              try{
                let st = document.getElementById(statusElId);
                if(st){
                  st.innerHTML = 'Poll started but choices not received yet. <button id="lateJoinRetryBtn" style="margin-left:6px;">Retry</button>';
                  const btn = document.getElementById('lateJoinRetryBtn');
                  if(btn){ btn.onclick = ()=>{ st.textContent='Retrying…'; attempts=0; setTimeout(tryLoad, 50); }; }
                }
              }catch(e){}
            }
        }
        setTimeout(tryLoad, schedule[attempts++]);
      }
    }catch(e){ console.warn('[late-join] reveal failed', e); }
  }

  function showPollChoicesAnimated(){
    const target = pollOptions || document.getElementById('poll-options');
    if(!target) return;
    setPollOptionsVisible(true);
    target.classList.remove('fade-in');
    target.classList.add('fade-out');
    setTimeout(()=>{ try{ renderPollOrWaiting(); }catch(e){} target.classList.remove('fade-out'); target.classList.add('fade-in'); }, 350);
  }
  function showWaitingMessage(msg){
    try{ renderLiveSlotPreview(); }catch(e){}
    try{ setNameControlsVisible(false); }catch(e){}
    setPollOptionsVisible(false);
    if(pollOptions) pollOptions.innerHTML = '';
    try{ const ro = document.getElementById('runoff-options'); if(ro){ ro.style.display='none'; ro.innerHTML=''; } }catch(e){}
    const target = document.getElementById('poll-status');
    if(!target) return;
    if(isLiveSlotPreviewActive()){
      target.innerHTML = '';
      return;
    }
    let selectionStarted = false;
    try{
      const publishedAt = localStorage.getItem('pollPublishedAt');
      const lastActiveAt = Number(window.__liveSlotLastActiveAt || 0);
      const recentlyActive = !!(lastActiveAt && ((Date.now() - lastActiveAt) < 30000));
      selectionStarted = !!(
        window.__slotSelectionStarted ||
        recentlyActive ||
        publishedAt
      );
    }catch(e){}
    // update debug banner with raw storage for visibility
    try{ debugBanner.textContent = 'local pollChoices: '+ (localStorage.getItem('pollChoices')||'null'); }catch(e){}
    if(msg && msg.indexOf && msg.indexOf('Wait until')===0 && !selectionStarted){
      const dogHtml = `
          <div class="wait-box">
            <img class="wait-dog dog-bob" src="../images/Merc.jpg" alt="Merc the dog" loading="lazy" />
            <div class="wait-text">Please wait patiently with Merc — the book selection process will begin soon.</div>
          </div>`;
      target.innerHTML = dogHtml;
      // Animate waiting area with a simple fade-in
      try{
        target.classList.remove('fade-in'); void target.offsetWidth; target.classList.add('fade-in');
      }catch(e){}
      return;
    }
    target.innerHTML = '<div class="text-muted small">'+(msg||'')+'</div>';
    try{ 
      target.classList.remove('fade-in'); void target.offsetWidth; target.classList.add('fade-in');
    }catch(e){}
  }

  // Render a tiebreaker runoff with single-choice (radio) voting
  function renderRunoff(choices){
    try{
      const ro = document.getElementById('runoff-options');
      if(!ro) return;
      // Hide normal poll UI and waiting status
      setPollOptionsVisible(false);
      const status = document.getElementById('poll-status'); if(status) status.innerHTML='';
  // Waiting area cleared; no slide transform adjustments needed
      ro.innerHTML = '';
      // Ensure name controls are visible and gating applies
      try{ initNameControlsFromSaved(); }catch(e){}
      ro.style.display='';

  const hdr = document.createElement('div');
      hdr.className = 'mb-2';
      hdr.innerHTML = '<strong>Tiebreaker vote:</strong> select one option';
      ro.appendChild(hdr);
      const groupName = 'runoff';
  const container = document.createElement('div');
      choices.forEach((c, idx)=>{

        const item = document.createElement('div');
        item.className = 'poll-item';
        const id = 'runoff_choice_'+idx;
        const book = (c && (c.book||c.title||c.display||'')) || '';
        const name = (c && (c.name||c.suggestedBy||'')) || '';
        item.innerHTML = `
          <div class="vote-container">
            <input type="radio" id="${id}" name="${groupName}" value="${book}">
            <label for="${id}" class="vote-label">Vote</label>
          </div>
          <div class="poll-content">
            <label for="${id}">${book}</label>
    <div class="suggested-by">Suggested by ${name}</div>
    <div class="book-meta" aria-live="polite">
      <div class="book-desc" data-book="${book}"></div>
      <div class="book-links">
        <a class="btn btn-sm btn-outline-secondary goodreads-link" data-book="${book}" href="${buildGoodreadsUrl(book)}" target="_blank" rel="noopener noreferrer" aria-label="View ${book} on Goodreads">Goodreads</a>
      </div>
    </div>
    <div class="voters" id="${slugifyId('runoff-'+book)}" data-book="${book}">Voted by: No votes yet</div>
    <div class="vote-total" data-book="${book}">Total Votes: 0</div>
          </div>`;
        container.appendChild(item);
        try{ const descEl = item.querySelector('.book-desc[data-book]'); if(descEl){ loadBookDescription(book, descEl); } }catch(e){}
        try{ const links = item.querySelector('.book-links'); if(links){ resolveAndApplyGoodreads(book, links); } }catch(e){}
      });
      ro.appendChild(container);
      // Dim until name present
      try{
        if(!voterName){ ro.classList.add('poll-needs-name'); } else { ro.classList.remove('poll-needs-name'); }
      }catch(e){}
      // Wire radio changes: single vote stored remotely
      Array.from(ro.querySelectorAll('input[type="radio"][name="'+groupName+'"]')).forEach(r =>{
        r.disabled = !voterName;
        r.addEventListener('change', ()=>{

          try{
            if(!voterName){ alert('Please submit your name before voting!'); return; }
            if(window.fbSyncAvailable && typeof window.fbSetRunoffVote === 'function'){
              window.fbSetRunoffVote(voterName, r.value);
            }
          }catch(e){}
        });
      });
      // Hook up live runoff "Voted by" updates
      try{
        if(window.fbSyncAvailable && typeof window.fbSubscribeRunoffVotes === 'function'){
          // Unsubscribe previous if any
          if(window.__unsubRunoffVotes){ try{ window.__unsubRunoffVotes(); }catch(e){} }
          window.__unsubRunoffVotes = window.fbSubscribeRunoffVotes(function(namesByBook){
            try{
              const data = namesByBook || {};
              Object.keys(data).forEach(book=>{
                const elId = slugifyId('runoff-'+book);
                let votersDiv = document.getElementById(elId);
                if(!votersDiv){
                  try{
                    const all = document.querySelectorAll('#runoff-options .voters[data-book]');
                    for(const el of all){ if((el.getAttribute('data-book')||'') === String(book)){ votersDiv = el; break; } }
                  }catch(e){}
                }
                if(votersDiv){ votersDiv.innerHTML = 'Voted by: ' + (data[book] && data[book].length ? data[book].join(', ') : 'No votes yet'); }
                // Update the Total Votes label in runoff
                try{
                  const count = (data[book] && data[book].length) ? data[book].length : 0;
                  try{
                    let totalEl = null; const allTotals = document.querySelectorAll('#runoff-options .vote-total[data-book]');
                    for(const el of allTotals){ if((el.getAttribute('data-book')||'') === String(book)){ totalEl = el; break; } }
                    if(totalEl){ totalEl.textContent = 'Total Votes: ' + count; }
                  }catch(e){}
                }catch(e){}
              });
            }catch(e){ console.warn('[voting_poll] apply runoff votes failed', e); }
          });
        }
      }catch(e){}
    }catch(e){ console.warn('[voting_poll] renderRunoff failed', e); }
  }

  // Render a winner announcement (admin final winner)
  function renderWinner(book){
    try{
      // Hide and clear any poll UI
      setPollOptionsVisible(false);
      try{ if(pollOptions){ pollOptions.innerHTML = ''; } }catch(e){}
      // Hide and clear any runoff UI
      try{
        const ro = document.getElementById('runoff-options');
        if(ro){ ro.style.display='none'; ro.innerHTML=''; }
        if(window.__unsubRunoffVotes){ try{ window.__unsubRunoffVotes(); }catch(e){} window.__unsubRunoffVotes = null; }
      }catch(e){}
  // Waiting area replaced by winner
      const status = document.getElementById('poll-status');
      if(!status) return;
      const rawBook = String(book||'');
      const safeBook = rawBook.replace(/</g,'&lt;');
      let safeSuggester = '';
      try{
        const w = JSON.parse(localStorage.getItem('pollWinner')||'null');
        const sugg = w && (w.suggestedBy || w.name || w.suggested_by);
        if(sugg) safeSuggester = String(sugg).replace(/</g,'&lt;');
      }catch(e){}
      const searchQuery = rawBook.split(' - ')[0].trim();
      const encoded = encodeURIComponent(searchQuery);
      status.innerHTML = `
        <div style="display:flex; justify-content:center;">
          <div class="card shadow-sm" style="padding:16px; text-align:center; max-width:520px; width:100%;">
            <h2 style="margin:0 0 6px 0; font-size:1.4rem;">Winner 🎉</h2>
            <div class="small text-muted">This month's book is:</div>
            <div class="winner-title" style="font-size:1.15rem; font-weight:700; margin-top:10px;">${safeBook}</div>
            ${safeSuggester ? `<div class="small text-muted" style="margin-top:6px;">Suggested by: ${safeSuggester}</div>` : ''}
            <div class="winner-cover-wrap"><img id="winner-cover" class="winner-cover" alt="Book cover" width="180" height="270" decoding="async" loading="eager" fetchpriority="high" referrerpolicy="no-referrer" /></div>
            <div class="small text-muted" style="margin-top:14px;">Find this book:</div>
            <div class="winner-links" style="margin-top:8px; display:flex; flex-wrap:wrap; gap:10px; justify-content:center;">
              <a class="btn btn-sm btn-outline-primary" style="min-width:120px;" href="https://www.amazon.com/s?k=${encoded}" target="_blank" rel="noopener noreferrer">Amazon</a>
              <a class="btn btn-sm btn-outline-warning" style="min-width:120px;" href="https://www.audible.com/search?keywords=${encoded}" target="_blank" rel="noopener noreferrer">Audible</a>
            </div>
          </div>
        </div>`;
      // remove outdated pollChoices to avoid reappearance
      try{ localStorage.removeItem('pollChoices'); }catch(e){}
    // Hide any name flow / prompt (issue #31)
    try{ hidePollEntryPrompt(); }catch(e){}
    try{ hideNameControlsAfterWinner(); }catch(e){}
    // Celebrate only if flagged as a live announcement
    try{ if(window.__celebrateWinnerNext){ startConfetti(6000); } }catch(e){}
    try{ window.__celebrateWinnerNext = false; }catch(e){}
    // Async cover load (non-blocking)
    try{ loadWinnerCover(rawBook); }catch(e){}
    }catch(e){ console.warn('[voting_poll] renderWinner error', e); }
  }

  // Lightweight, cached cover loader using Open Library; non-blocking with timeout
  function loadWinnerCover(rawBook){
    try{
      const img = document.getElementById('winner-cover');
      if(!img) { try{ showWinnerCoverPlaceholder(); }catch(e){} return; }
      // Parse "Title - Author" (preferred) while tolerating extra hyphens
      const parts = parseBookParts(String(rawBook||'').trim());
      const titlePart = (parts && parts.title) ? parts.title.trim() : String(rawBook||'').trim();
      const authorPart = (parts && parts.author) ? parts.author.trim() : '';
      const normKey = (titlePart + (authorPart ? (' - ' + authorPart) : '')).toLowerCase();
      const cacheNs = 'winnerCoverCache_v1';
      let cache = {};
      try{ cache = JSON.parse(localStorage.getItem(cacheNs)||'{}')||{}; }catch(e){}
      const now = Date.now();
      const hit = cache[normKey];
      if(hit && hit.url && (now - (hit.ts||0) < 14*24*60*60*1000)){
        img.onload = ()=> img.classList.add('ready');
        img.onerror = ()=>{ try{ showWinnerCoverPlaceholder(); }catch(e){} };
        img.src = hit.url;
        return;
      }
      const controller = new AbortController();
      const searchTimeout = setTimeout(()=>{ try{ controller.abort(); }catch(e){} }, 2500);
      const buildCandidates = (docs)=>{
        const candidates = [];
        for(const d of (Array.isArray(docs) ? docs : [])){
          if(!d) continue;
          if(d.cover_i){ candidates.push(`https://covers.openlibrary.org/b/id/${d.cover_i}-L.jpg`); }
          else if(Array.isArray(d.isbn) && d.isbn.length){ candidates.push(`https://covers.openlibrary.org/b/isbn/${d.isbn[0]}-L.jpg`); }
          if(candidates.length >= 5) break;
        }
        return Array.from(new Set(candidates));
      };
      const finishWith = (url, resolvedRef)=>{
        if(resolvedRef.resolved) return; resolvedRef.resolved = true;
        img.onload = ()=>{
          try{ img.classList.add('ready'); }catch(e){}
          try{ cache[normKey] = { url, ts: Date.now() }; localStorage.setItem(cacheNs, JSON.stringify(cache)); }catch(e){}
        };
        img.onerror = ()=>{ try{ showWinnerCoverPlaceholder(); }catch(e){} };
        img.src = url;
      };
      const tryCandidates = (uniq)=>{
        if(!uniq || uniq.length === 0) throw new Error('no candidates');
        const resolvedRef = { resolved: false };
        const overallTo = setTimeout(()=>{ if(!resolvedRef.resolved){ try{ showWinnerCoverPlaceholder(); }catch(e){} } }, 2200);
        uniq.forEach((u, idx)=>{
          try{
            const probe = new Image();
            probe.decoding = 'async';
            probe.loading = 'eager';
            probe.referrerPolicy = 'no-referrer';
            setTimeout(()=>{
              probe.onload = ()=>{ try{ clearTimeout(overallTo); }catch(e){} finishWith(u, resolvedRef); };
              probe.onerror = ()=>{ /* try others */ };
              probe.src = u;
            }, idx * 60);
          }catch(e){}
        });
      };
      const titleQ = encodeURIComponent(titlePart);
      const authorQ = authorPart ? ('&author=' + encodeURIComponent(authorPart)) : '';
      fetch('https://openlibrary.org/search.json?title='+titleQ+authorQ, { signal: controller.signal })
        .then(r=> r.ok ? r.json() : Promise.reject(new Error('http '+r.status)))
        .then(data=>{
          let uniq = buildCandidates(data && data.docs);
          if(uniq.length === 0 && authorPart){
            return fetch('https://openlibrary.org/search.json?title='+titleQ, { signal: controller.signal })
              .then(r=> r.ok ? r.json() : Promise.reject(new Error('http '+r.status)))
              .then(d2=>{ uniq = buildCandidates(d2 && d2.docs); return uniq; });
          }
          return uniq;
        })
        .then((uniq)=>{ tryCandidates(uniq); })
        .catch(()=>{ try{ showWinnerCoverPlaceholder(); }catch(e){} })
        .finally(()=>{ try{ clearTimeout(searchTimeout); }catch(e){} });
    }catch(e){ try{ showWinnerCoverPlaceholder(); }catch(_){} }
  }

  // Placeholder UI when cover cannot be loaded
  function showWinnerCoverPlaceholder(){
    try{
      const wrap = document.querySelector('.winner-cover-wrap');
      if(!wrap) return;
      const img = document.getElementById('winner-cover');
      if(img){ try{ img.remove(); }catch(e){} }
      if(wrap.querySelector('.winner-cover--placeholder')) return;
      const ph = document.createElement('div');
      ph.className = 'winner-cover winner-cover--placeholder ready';
      ph.innerHTML = '<div class="ph"><span class="ph-line ph-title">Cover</span><span class="ph-line ph-title">Unavailable</span></div>';
      wrap.appendChild(ph);
    }catch(e){}
  }

  // Proactive prewarm: fetch likely cover URLs for current poll choices so winner loads instantly
  (function(){
    // Set of normalized titles already prewarmed in this session
    const prewarmed = new Set();
    const cacheNs = 'winnerCoverCache_v1';
    function normalizeTitle(raw){
      try{
        const parts = parseBookParts(String(raw||'').trim());
        const title = (parts && parts.title) ? parts.title.trim() : String(raw||'').trim();
        const author = (parts && parts.author) ? parts.author.trim() : '';
        return (title + (author ? (' - ' + author) : '')).toLowerCase();
      }catch(e){ return String(raw||'').toLowerCase(); }
    }
    function prefetchImage(url){
      try{ const img = new Image(); img.decoding = 'async'; img.loading = 'eager'; img.referrerPolicy = 'no-referrer'; img.src = url; }catch(e){}
      try{
        // Hint browser to prefetch as image
        const l = document.createElement('link'); l.rel = 'prefetch'; l.as = 'image'; l.href = url; document.head.appendChild(l);
      }catch(e){}
    }
    async function prewarmCoverForTitle(rawBook){
      try{
        const parts = parseBookParts(String(rawBook||'').trim());
        const titlePart = (parts && parts.title) ? parts.title.trim() : String(rawBook||'').trim();
        const authorPart = (parts && parts.author) ? parts.author.trim() : '';
        const normKey = normalizeTitle(rawBook);
        if(!titlePart || prewarmed.has(normKey)) return; prewarmed.add(normKey);
        let cache = {};
        try{ cache = JSON.parse(localStorage.getItem(cacheNs)||'{}')||{}; }catch(e){}
        const now = Date.now();
        const hit = cache[normKey];
        if(hit && hit.url && (now - (hit.ts||0) < 14*24*60*60*1000)){
          // Already cached recently; just ensure the image is in memory/disk cache
          prefetchImage(hit.url);
          return;
        }
        const controller = new AbortController();
        const to = setTimeout(()=>{ try{ controller.abort(); }catch(e){} }, 1800);
        const q = encodeURIComponent(titlePart);
        const aq = authorPart ? ('&author=' + encodeURIComponent(authorPart)) : '';
        let resp = await fetch('https://openlibrary.org/search.json?title='+q+aq, { signal: controller.signal });
        if(!resp.ok) throw new Error('http '+resp.status);
        let data = await resp.json();
        let docs = (data && Array.isArray(data.docs)) ? data.docs : [];
        if((!docs || !docs.length) && authorPart){
          resp = await fetch('https://openlibrary.org/search.json?title='+q, { signal: controller.signal });
          if(resp.ok){ data = await resp.json(); docs = (data && Array.isArray(data.docs)) ? data.docs : []; }
        }
        let picked = null;
        for(const d of docs){ if(d && d.cover_i){ picked = d; break; } }
        if(!picked){ for(const d of docs){ if(d && Array.isArray(d.isbn) && d.isbn.length){ picked = d; break; } } }
        if(!picked) return;
        let url = '';
        if(picked.cover_i){ url = `https://covers.openlibrary.org/b/id/${picked.cover_i}-L.jpg`; }
        else { const isbn = picked.isbn[0]; url = `https://covers.openlibrary.org/b/isbn/${isbn}-L.jpg`; }
        if(url){
          prefetchImage(url);
          try{ cache[normKey] = { url, ts: Date.now() }; localStorage.setItem(cacheNs, JSON.stringify(cache)); }catch(e){}
        }
        try{ clearTimeout(to); }catch(e){}
      }catch(e){ /* silent prewarm */ }
    }
    // Expose a scheduler the poll renderer can call after showing choices
    window.schedulePrewarmPollCovers = function(){
      try{
        const choices = getPollChoices();
        if(!Array.isArray(choices) || !choices.length) return;
        // Stagger requests slightly to stay friendly; limit to first 5
        choices.slice(0,5).forEach((c, i)=>{
          const t = c && (c.book||c.title||c.display||'');
          if(!t) return;
          setTimeout(()=>{ prewarmCoverForTitle(t); }, 80*i);
        });
      }catch(e){}
    };
  })();

  // Lightweight confetti animation (restored)
  function startConfetti(durationMs){
    try{
      const reduce = window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches;
      if(reduce) return;
      // Cleanup any existing animation
      try{ if(window.__confettiCleanup){ window.__confettiCleanup(); window.__confettiCleanup = null; } }catch(e){}
      const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
      const canvas = document.createElement('canvas');
      canvas.className = 'confetti-canvas';
      canvas.width = Math.floor(window.innerWidth * dpr);
      canvas.height = Math.floor(window.innerHeight * dpr);
      canvas.style.width = '100vw';
      canvas.style.height = '100vh';
      const ctx = canvas.getContext('2d');
      ctx.scale(dpr, dpr);
      document.body.appendChild(canvas);
      const colors = ['#E91E63','#9C27B0','#3F51B5','#2196F3','#00BCD4','#4CAF50','#FFC107','#FF5722'];
      const W = () => window.innerWidth;
      const H = () => window.innerHeight;
      const count = Math.max(140, Math.floor(W()/6));
      const gravity = 0.25;
      const drag = 0.005;
      const wind = () => Math.sin(Date.now()/900) * 0.04;
      const rand = (a,b)=> a + Math.random()*(b-a);
      const parts = [];
      for(let i=0;i<count;i++){
        parts.push({
          x: Math.random()*W(), y: rand(-H(), 0),
          w: rand(6,12), h: rand(6,14),
          vx: rand(-0.6,0.6), vy: rand(1.5,3.8),
          rot: rand(0, Math.PI*2), vr: rand(-0.2,0.2),
          col: colors[Math.floor(Math.random()*colors.length)],
          shape: Math.random() < 0.25 ? 'tri' : 'rect',
          alpha: 1
        });
      }
      let rafId = 0;
      let ended = false;
      const endAt = Date.now() + (Number.isFinite(durationMs) ? durationMs : 5000);
      function resize(){
        const ndpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
        if(ndpr !== dpr){ /* keep scale simple; skip live DPR changes */ }
        canvas.width = Math.floor(W()*dpr);
        canvas.height = Math.floor(H()*dpr);
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      }
      const onResize = ()=>{ try{ resize(); }catch(e){} };
      window.addEventListener('resize', onResize);
      function draw(){
        ctx.clearRect(0,0,W(),H());
        const w = wind();
        for(const p of parts){
          p.vx += w;
          p.vx *= (1 - drag);
          p.vy += gravity;
          p.x += p.vx;
          p.y += p.vy;
          p.rot += p.vr;
          // recycle off-screen pieces to the top for a steady shower until duration ends
          if(Date.now() < endAt){
            if(p.y > H()+20 || p.x < -20 || p.x > W()+20){
              p.x = Math.random()*W();
              p.y = -10;
              p.vx = rand(-0.6,0.6); p.vy = rand(1.5,3.8);
            }
          } else {
            // after duration, fade out and let them fall
            p.alpha = Math.max(0, p.alpha - 0.02);
          }
          if(p.alpha <= 0) continue;
          ctx.save();
          ctx.globalAlpha = p.alpha;
          ctx.translate(p.x, p.y);
          ctx.rotate(p.rot);
          ctx.fillStyle = p.col;
          if(p.shape === 'rect'){
            ctx.fillRect(-p.w/2, -p.h/2, p.w, p.h);
          } else {
            ctx.beginPath();
            ctx.moveTo(0, -p.h/2);
            ctx.lineTo(p.w/2, p.h/2);
            ctx.lineTo(-p.w/2, p.h/2);
            ctx.closePath();
            ctx.fill();
          }
          ctx.restore();
        }
        if(Date.now() > endAt + 1200){
          cleanup();
          return;
        }
        rafId = requestAnimationFrame(draw);
      }
      function cleanup(){
        if(ended) return; ended = true;
        cancelAnimationFrame(rafId);
        window.removeEventListener('resize', onResize);
        try{ canvas.remove(); }catch(e){}
      }
      window.__confettiCleanup = cleanup;
      draw();
    }catch(e){ /* noop */ }
  }
  // Banner control (shows when votes are reset via Slot Machine reset)
  const pollResetBanner = document.getElementById('poll-reset-banner');
  function showResetBanner(text){ if(pollResetBanner){ pollResetBanner.textContent = text; pollResetBanner.style.display = 'block'; setTimeout(()=>{ if(pollResetBanner) pollResetBanner.style.display='none'; }, 8000); } }

  // Event listeners for cross-tab and admin events
  // Only respond to published poll notifications and winner announcements via storage events
  window.addEventListener('storage', (ev)=>{
    try{
      // Respect boot-time block
      if(window.__viewerBlockApply){ try{ console.log('[voting_poll] storage ignored due to boot block'); }catch(e){} return; }
      // If viewer chose to ignore server polls, do not react
      if(viewerIsIgnoring()) return;
      // When admin publishes, they set pollPublishedAt; respond to that key only
      if(ev.key === 'pollPublishedAt'){
        try{
          if(ev.newValue){
            // A new publish happened — render poll if pollChoices exist
            console.log('[voting_poll] storage event: pollPublishedAt set');
            try{ renderPollOrWaiting(); }catch(e){}

        try{ updateDebugBanner(); }catch(e){}
          } else {
            // Publish removed — return to waiting UI
            try{ localStorage.removeItem('pollChoices'); }catch(e){}
        try{ renderPollOrWaiting(); }catch(e){}

      try{ updateDebugBanner(); }catch(e){}
          }
        }catch(e){ console.warn('[voting_poll] pollPublishedAt storage handler', e); }
        return;
      }
      // Also respond to pollChoices writes in case admin wrote choices and publishedAt together
    if(ev.key === 'pollChoices' && ev.newValue){ try{ console.log('[voting_poll] storage event: pollChoices changed'); try{ renderPollOrWaiting(); }catch(e){} try{ updateDebugBanner(); }catch(e){} }catch(e){} return; }
      // Winner announcements are respected
      if(ev.key === 'pollWinner' && ev.newValue){
        try{ const p = JSON.parse(ev.newValue); if(p && p.book){ try{ localStorage.removeItem('pollChoices'); }catch(e){} renderWinner(p.book); } }catch(e){}
    try{ updateDebugBanner(); }catch(e){}
        return;
      }
    }catch(e){ console.warn('[voting_poll] storage handler error', e); }
  });
  window.addEventListener('pollPublished', (ev)=>{ try{ renderPollOrWaiting(); }catch(e){} });
  window.addEventListener('pollCleared', (ev)=>{
    try{ window.__slotSelectionStarted = false; }catch(e){}
    try{ window.__liveSlotLastActiveAt = 0; }catch(e){}
    try{ renderPollOrWaiting(); }catch(e){}
  });
    // Listen for winner announcements from admin and broadcast channel
  window.addEventListener('pollWinner', (ev)=>{
      try{
        const payload = (ev && ev.detail) || JSON.parse(localStorage.getItem('pollWinner')||'null');
        if(payload && payload.book){
      try{ window.__celebrateWinnerNext = true; }catch(e){}
          // clear any persisted pollChoices so stale polls can't reappear
          try{ localStorage.removeItem('pollChoices'); }catch(e){}
          try{ debugBanner.textContent = 'Winner announced: '+payload.book; }catch(e){}
          // render a special winner UI
          try{ renderWinner(payload.book); }catch(e){ console.log('[voting_poll] winner render failed', e); }
          // stop showing runoff UI once winner is announced
          try{ const ro = document.getElementById('runoff-options'); if(ro){ ro.style.display='none'; ro.innerHTML=''; } }catch(e){}
        }
      }catch(e){ console.warn('[voting_poll] pollWinner handler', e); }
    });
  try{
    const _bc = new BroadcastChannel('book-club');
    _bc.addEventListener('message', (ev)=>{
      try{
        const d = ev.data || {};
        if(window.__viewerBlockApply){ try{ console.log('[voting_poll] BC ignored due to boot block'); }catch(e){} return; }
        if(viewerIsIgnoring()) return;
        if(d && d.type === 'pollWinner' && d.winner){
          try{ window.__celebrateWinnerNext = true; }catch(e){}
          try{ localStorage.setItem('pollWinner', JSON.stringify(d.winner)); }catch(e){}
          try{ localStorage.removeItem('pollChoices'); }catch(e){}
          try{ renderWinner(d.winner.book || d.winner); }catch(e){}
        }
      }catch(e){ console.warn('[voting_poll] BC handler error', e); }
    });
  }catch(e){ /* BroadcastChannel not available; storage events still work */ }
  // Listen for winner announcements via storage events (other tabs)
  window.addEventListener('storage', (ev)=>{
    try{
    // Ignore pollWinner storage events during the boot window to avoid rendering stale winners
    if(window.__viewerBlockApply){ try{ console.log('[voting_poll] storage(pollWinner) ignored due to boot block'); }catch(e){} return; }
      if(ev.key === 'pollWinner' && ev.newValue){
        try{ const p = JSON.parse(ev.newValue); if(p && p.book){ try{ window.__celebrateWinnerNext = true; }catch(e){} try{ localStorage.removeItem('pollChoices'); }catch(e){} renderWinner(p.book); } }catch(e){}
      }
    }catch(e){ console.warn('[voting_poll] storage pollWinner handler', e); }
  });
  window.addEventListener('load', ()=>{

    try{
      const stored = JSON.parse(localStorage.getItem('pollChoices') || 'null');
      const hasPoll = Array.isArray(stored) && stored.length >= 3;
      if(!hasPoll){
        try{ localStorage.removeItem('pollChoices'); }catch(e){}
        try{ if(pollOptions) pollOptions.innerHTML = ''; }catch(e){}
        try{ renderPollOrWaiting(); }catch(e){}
        console.log('[voting_poll] defensive clear ran: no pollChoices present');
      } else {
        console.log('[voting_poll] pollChoices present on load');
      }
      // Migrate session-only ignore flag to persistent localStorage so a prior Clear persists across reloads
      try{
        if(sessionStorage.getItem('viewerIgnoreServerPolls') && !localStorage.getItem('viewerIgnoreServerPolls')){
          localStorage.setItem('viewerIgnoreServerPolls', '1');
          console.log('[voting_poll] migrated viewerIgnoreServerPolls from sessionStorage -> localStorage');
        }
      }catch(e){}
      // If this viewer previously cleared the poll and chose to ignore server polls, reflect that in the UI
      try{
        if(localStorage.getItem('viewerIgnoreServerPolls')){
          try{ debugBanner.textContent = 'Viewer is ignoring server polls'; }catch(e){}
        }
      }catch(e){}
      // Wire up the enter name prompt button
      try{ const enterBtn = document.getElementById('enterNameBtn'); if(enterBtn) enterBtn.addEventListener('click', ()=>{ try{ beginNameFlow(); }catch(e){} }); }catch(e){}
      // If a winner was already announced before this viewer loaded, render winner immediately (issue #31)
      try{
        const existingWinner = JSON.parse(localStorage.getItem('pollWinner')||'null');
        if(existingWinner && existingWinner.book){ renderWinner(existingWinner.book); }
      }catch(e){}
    }catch(e){ console.warn('[voting_poll] defensive clear error', e); }
  });

  // Live cross-device votes subscription (regular poll)
  (function(){
    try{
      if(window.fbSyncAvailable && typeof window.fbSubscribeVotes === 'function'){
    window.fbSubscribeVotes(function(namesByBook){
          try{
      try{ console.log('[voting_poll] remote votes snapshot', namesByBook); }catch(e){}
      // Treat Firestore as source of truth: overwrite local votes with remote
      const incoming = namesByBook || {};
      votes = {};
      Object.keys(incoming).forEach(book=>{ votes[book] = (incoming[book]||[]).slice(); });
            // Refresh UI for visible books
            try{ const pollChoices = getPollChoices(); (pollChoices||[]).forEach(c=> updateVoters(c.book)); }catch(e){}
          }catch(e){ console.warn('[voting_poll] apply remote votes failed', e); }
        });
      }
    }catch(e){}
  })();
</script>
      </div>
    </div>
  </div>
</body>
</html>

<script>
// Failsafe: on some mobile refreshes, scripts may race and render nothing; ensure a waiting UI appears.
(function(){
  function hasContent(el){ try{ return !!(el && String(el.textContent||'').trim().length); }catch(e){ return false; } }
  function ensureNotBlank(){
    try{
      const status = document.getElementById('poll-status');
      const ready = document.getElementById('poll-ready');
      const options = document.getElementById('poll-options');
      const runoff = document.getElementById('runoff-options');
      const winnerEl = document.querySelector('.winner-cover-wrap');
      // Respect name gating: don't auto-insert Merc waiting box if user hasn't submitted a name yet
      let savedName = '';
      let publishedAt = '';
      let livePreviewActive = false;
      let selectionStarted = false;
      try { savedName = (localStorage.getItem('voterName')||'').trim(); } catch(e){}
      try { publishedAt = localStorage.getItem('pollPublishedAt')||''; } catch(e){}
      try {
        const lastActiveAt = Number(window.__liveSlotLastActiveAt || 0);
        const recentlyActive = !!(lastActiveAt && ((Date.now() - lastActiveAt) < 30000));
        selectionStarted = !!(window.__slotSelectionStarted || recentlyActive || publishedAt);
      } catch(e){}
      try {
        const preview = window.__liveSlotPreview;
        const reels = Array.isArray(preview && preview.reels) ? preview.reels.slice(0,3) : [];
        livePreviewActive = !!(preview && preview.active && reels.length && !publishedAt);
      } catch(e){}
      const nothingShown = !winnerEl && (
        !options || options.style.display==='none' || options.children.length===0
      ) && (
        !runoff || runoff.style.display==='none' || runoff.children.length===0
      ) && (
        !ready || ready.classList.contains('d-none') || ready.style.display==='none' || !hasContent(ready)
      ) && (
        !status || !hasContent(status)
      );
      if(nothingShown && status){
        if(livePreviewActive){
          status.innerHTML = '';
          return;
        }
        if(selectionStarted){
          status.innerHTML = '';
          return;
        }
        status.innerHTML = '<div class="wait-box" data-src="failsafe">\
          <img class="wait-dog dog-bob" src="../images/Merc.jpg" alt="Merc the dog" loading="lazy" />\
          <div class="wait-text">Please wait patiently with Merc — the book selection process will begin soon.</div>\
        </div>';
      }
    }catch(e){}
  }
  window.addEventListener('load', function(){
    setTimeout(ensureNotBlank, 120);
    setTimeout(ensureNotBlank, 800);
    setTimeout(ensureNotBlank, 2200);
  });
})();
</script>

