<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Voting Poll</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
    /* keep minimal header button style for Main Page */
    .main-btn-header { text-align:center; margin:1rem 0; }
    .main-btn-header .btn { padding:0.6rem 1rem; }
  </style>
  <!-- Favicons -->
  <link rel="icon" href="/favicon/favicon.ico" />
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon/favicon-32x32.png" />
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon/favicon-16x16.png" />
  <link rel="apple-touch-icon" sizes="180x180" href="/favicon/apple-touch-icon.png" />
  <link rel="manifest" href="/favicon/site.webmanifest" />
  <meta name="theme-color" content="#ffffff">
  <style>
    body { font-family: sans-serif; max-width: 500px; margin: 2em auto; text-align: center; }
    .section { background: #fafafa; border-radius: 12px; border: 1px solid #ddd; margin: 1.5em 0; padding: 1em 0.5em; }
    .poll-item { margin: 15px 0; padding: 15px; border: 1px solid #ccc; border-radius: 8px; background: #f9f9f9; display: flex; align-items: center; }
    .vote-container { display: flex; align-items: center; justify-content: center; padding: 10px; border: 1px solid #ddd; border-radius: 8px; background: #f0f0f0; margin-right: 15px; }
    .vote-container input[type="checkbox"] { transform: scale(1.5); margin-right: 10px; cursor: pointer; }
    .vote-container input[type="checkbox"]:disabled { cursor: not-allowed; opacity: 0.5; } /* Grayed-out style for disabled checkboxes */
    .vote-container label { font-size: 1.1em; color: #333; font-weight: normal; } /* Un-bolded by default */
    .vote-container label.bold { font-weight: bold; } /* Bold when enabled */
    .poll-content { text-align: center; flex: 1; }
    .poll-content label { font-size: 1.2em; display: block; margin-bottom: 5px; font-weight: bold; } /* Bold book names */
    .poll-content .suggested-by { font-size: 1em; color: #555; margin-top: 5px; font-style: italic; } /* Author name under book title */
    .voters { font-size: 0.9em; color: #555; margin-top: 10px; text-align: center; }
    .voters span { margin-right: 5px; display: inline-block; }
    #nameInput { margin-bottom: 15px; padding: 10px; font-size: 1em; width: 70%; border: 1px solid #ccc; border-radius: 5px; display: inline-block; transition: width 0.3s ease; }
    #submitNameBtn { margin-left: 10px; padding: 10px 15px; font-size: 1em; cursor: pointer; display: inline-block; }
    #editNameBtn { margin-top: 10px; padding: 10px 15px; font-size: 1em; cursor: pointer; }
    /* Additional styles for winners section */
    .card { border: 1px solid #ddd; border-radius: 8px; background: #fff; }
    .card-title { font-size: 1.5em; margin: 0; }
    .text-muted { color: #888; }
    .small { font-size: 0.9em; }
    .mb-2 { margin-bottom: 0.5em; }
    .mt-2 { margin-top: 0.5em; }
    .fs-5 { font-size: 1.25em; }
    .shadow-sm { box-shadow: 0 1px 2px rgba(0,0,0,0.1); }
    /* transition helpers */
    .fade-in { animation: fadeIn 420ms cubic-bezier(.2,.8,.2,1) both; }
    .fade-out { animation: fadeOut 300ms cubic-bezier(.2,.8,.2,1) both; }
    @keyframes fadeIn { from { opacity: 0; transform: translateY(8px); } to { opacity: 1; transform: none; } }
    @keyframes fadeOut { from { opacity: 1; transform: none; } to { opacity: 0; transform: translateY(-8px); } }
  /* Waiting view styles */
  .wait-box { display:flex; flex-direction:column; align-items:center; gap:12px; padding:12px; }
  .wait-dog { width:220px; max-width:90%; border-radius:12px; box-shadow:0 6px 18px rgba(0,0,0,0.12); }
  .wait-text { font-size:1.05em; color:#333; max-width:380px; text-align:center; }
  .wait-sub { color:#666; font-size:0.95em; }
  .spinner { width:48px; height:48px; border:5px solid #eee; border-top-color:#007bff; border-radius:50%; animation:spin 1s linear infinite; }
  @keyframes spin { to { transform:rotate(360deg); } }
  .dog-bob { animation: bob 2s ease-in-out infinite; }
  @keyframes bob { 0%{transform:translateY(0)}50%{transform:translateY(-6px)}100%{transform:translateY(0)} }
  </style>
</head>

<body>
  <header class="main-btn-header">
    <a href="index.html" class="btn btn-secondary">üè† Main Page</a>
  </header>
  <h1>üìä Voting Poll</h1>

  <div class="section">
  <h2>Vote for the next book - toggle your votes</h2>
  <input type="text" id="nameInput" placeholder="Enter your name" />
  <button id="submitNameBtn">Submit Name</button>
  <button id="editNameBtn" style="display: none;">Edit Name</button>
  <p class="text-muted small mb-2 mt-2">Please vote for which book(s) you'd like to read next month ‚Äî you may vote for more than one option.</p>
  <div id="poll-reset-banner" style="display:none; margin-top:12px; padding:8px; border-radius:6px; background:#fff3cd; color:#856404; border:1px solid #ffeeba; font-size:0.95em;"></div>
  <!-- Poll UI (legacy) -->
  <div id="poll-options"></div>
  </div>

  <!-- Selected Books section removed -->

  <script>
  // Legacy poll UI only. Helper functions and rendering live in the older script below.
  // No-op here - legacy script will handle rendering into #poll-options and respond to pollChoices changes.
  </script>
  <script>
  let pollChoices = JSON.parse(localStorage.getItem("pollChoices")) || []; // Load poll choices
  // Normalize any legacy or internal shapes into {book,name}
  if (Array.isArray(pollChoices) && pollChoices.length){
    pollChoices = pollChoices.map(item => {
      if (!item) return item;
      // accept shapes: {book,name} or {book,title,name} or {title,book,name}
      const book = item.book || item.display || item.title || item[0] || '';
      const name = item.name || item.suggestedBy || item[1] || '';
      return { book: String(book), name: String(name) };
    });
  }
    // persist and render as {book,name} array
    const persisted = pollChoices.map(i => ({ book: i.book, name: i.name || '' }));
    // helper to persist pollChoices and clear votes if the poll changed
    function persistPollChoices(arr){
      try{
        const newStr = JSON.stringify(arr || []);
        const oldStr = localStorage.getItem('pollChoices') || null;
        // If the poll choices changed, clear votes (new poll)
        if(oldStr !== newStr){
          try{ localStorage.removeItem('votes'); }catch(e){}
          // notify other tabs (storage event will fire there)
          try{ window.dispatchEvent(new StorageEvent('storage', { key:'votes', newValue: null })); }catch(e){}
        }
        localStorage.setItem('pollChoices', newStr);
        pollChoices = JSON.parse(newStr);
      }catch(e){ console.warn('persistPollChoices failed', e); }
    }
    persistPollChoices(persisted);
  let votes = JSON.parse(localStorage.getItem("votes")) || {}; // Load votes
  const pollOptions = document.getElementById("poll-options");
  let pollVisible = false; // true when poll UI is currently shown (prevents re-triggering animation)
    const nameInput = document.getElementById("nameInput");
    const submitNameBtn = document.getElementById("submitNameBtn");
    const editNameBtn = document.getElementById("editNameBtn");
    let voterName = ""; // Store the confirmed voter name

    // Display poll options
    function loadPollChoices() {
      pollOptions.innerHTML = ""; // Clear existing options
      pollChoices.forEach((choice, index) => {
        const option = document.createElement("div");
        option.className = "poll-item";
        option.innerHTML = `
          <div class="vote-container">
            <input type="checkbox" id="choice${index}" name="poll" value="${choice.book}">
            <label for="choice${index}" class="vote-label">Vote</label>
          </div>
          <div class="poll-content">
            <label for="choice${index}">${choice.book}</label>
            <div class="suggested-by">Suggested by ${choice.name}</div>
            <div class="voters" id="voters-old-${choice.book}">Voted by: ${getVoters(choice.book)}</div>
          </div>
        `;
        pollOptions.appendChild(option);

        // Wire up checkbox state according to current voterName and votes
        const checkbox = option.querySelector("input[type='checkbox']");
        const voteLabel = option.querySelector('.vote-label');
        // Disabled if no confirmed voter name
        checkbox.disabled = !voterName;
        // Checked if the current voter has voted for this book
        try{ checkbox.checked = isUserVoted(choice.book); }catch(e){}
        if(voterName){ voteLabel.classList.add('bold'); } else { voteLabel.classList.remove('bold'); }
        // Add event listener for toggling votes
        checkbox.addEventListener("change", () => toggleVote(choice.book));
      });
    }

    // Check if the current user has voted for a book
    function isUserVoted(book) {
      return votes[book]?.includes(voterName);
    }

    // Get the list of voters for a book
    function getVoters(book) {
      return votes[book]?.join(", ") || "No votes yet"; // Separate voters with commas
    }

    // Toggle vote for a book
    function toggleVote(book) {
      if (!voterName) {
        alert("Please submit your name before voting!");
        return;
      }

      if (!votes[book]) votes[book] = []; // Initialize votes array for the book

      if (isUserVoted(book)) {
        // Remove the user's vote
        votes[book] = votes[book].filter(voter => voter !== voterName);
      } else {
        // Add the user's vote
        votes[book].push(voterName);
      }

      localStorage.setItem("votes", JSON.stringify(votes)); // Save votes to localStorage
      updateVoters(book); // Update the voters list
    }

    // Update the voters list for a book
    function updateVoters(book) {
  const votersDiv = document.getElementById(`voters-old-${book}`);
  if (votersDiv) votersDiv.innerHTML = `Voted by: ${getVoters(book)}`;
  // Update checkbox checked state and label bolding so re-renders keep correct enable state
  try{
    const checkbox = document.querySelector(`input[type='checkbox'][value="${book}"]`);
    const voteLabel = checkbox ? checkbox.parentElement.querySelector('.vote-label') : null;
    if(checkbox){ checkbox.checked = isUserVoted(book); checkbox.disabled = !voterName; }
    if(voteLabel){ if(voterName) voteLabel.classList.add('bold'); else voteLabel.classList.remove('bold'); }
  }catch(e){}
    }

    // Handle name submission
    function submitName() {
      const name = nameInput.value.trim();
      if (!name) {
        alert("Please enter your name!");
        return;
      }

      voterName = name; // Save the confirmed name
      nameInput.disabled = true; // Disable the name input
      nameInput.style.width = `${name.length + 2}ch`; // Adjust the width to fit the name
      submitNameBtn.style.display = "none"; // Hide the submit button
      editNameBtn.style.display = "inline-block"; // Show the edit button

      // Enable all checkboxes and bold the "Vote" labels
      const checkboxes = document.querySelectorAll('input[type="checkbox"]');
      const labels = document.querySelectorAll('.vote-label');
      checkboxes.forEach(checkbox => checkbox.disabled = false);
      labels.forEach(label => label.classList.add('bold'));
    }

    // Handle name editing
    function editName() {
      nameInput.disabled = false; // Enable the name input
      nameInput.style.width = "70%"; // Reset the width
      submitNameBtn.style.display = "inline-block"; // Show the submit button
      editNameBtn.style.display = "none"; // Hide the edit button
      voterName = ""; // Clear the confirmed name

      // Disable all checkboxes and un-bold the "Vote" labels
      const checkboxes = document.querySelectorAll('input[type="checkbox"]');
      const labels = document.querySelectorAll('.vote-label');
      checkboxes.forEach(checkbox => checkbox.disabled = true);
      labels.forEach(label => label.classList.remove('bold'));
    }

    // Event listeners for name submission and editing
    submitNameBtn.addEventListener("click", submitName);
    editNameBtn.addEventListener("click", editName);

    // Load poll choices on page load
    loadPollChoices();

    // helper to animate showing the poll choices
    function showPollChoicesAnimated(){
      const target = pollOptions || document.getElementById('poll-options');
      if(!target) return;
      // fade out current content (waiting UI) then render poll and fade in
      target.classList.remove('fade-in');
      target.classList.add('fade-out');
      setTimeout(()=>{
        try{ loadPollChoices(); }catch(e){}
        target.classList.remove('fade-out');
        target.classList.add('fade-in');
      }, 350);
    }

  // Banner control (shows when votes are reset via Slot Machine reset)
  const pollResetBanner = document.getElementById('poll-reset-banner');
  function showResetBanner(text){ if(pollResetBanner){ pollResetBanner.textContent = text; pollResetBanner.style.display = 'block'; setTimeout(()=>{ if(pollResetBanner) pollResetBanner.style.display='none'; }, 8000); } }

  <!-- Pull the three chosen indexes from slotMachineState and render titles/names -->
  async function loadWinnersAndChoices(){
      const CSV_URL = "https://docs.google.com/spreadsheets/d/e/2PACX-1vSLdPdPu4pwIwsAjADiCQOXYUJ8ACgWXaJn0DUVgNEy8ZZfc06EUGz2G9imE4gQ9FRs_zoDamhYTHhQ/pub?output=csv";
      const container = document.getElementById('winners-container');
      const loading = document.getElementById('winners-loading');

      function showMessage(msg){
        // If this is the waiting message, render a friendlier UI with dog and spinner
        const waitingText = 'Wait until the lead has randomly chosen all three books with the slot machine.';
        if(msg && msg.indexOf('Wait until')===0){
          const dogHtml = `
            <div class="wait-box">
              <img class="wait-dog dog-bob" src="https://cdn.discordapp.com/attachments/737108335978872904/1407440695492612106/IMG_0875.jpg?ex=68a61cca&is=68a4cb4a&hm=4e7a7a17723d3e1309b25fe9030a3020a450aff960780721f6778abbcac22b1f&" alt="Merc the dog" />
              <div class="wait-text">Please wait patiently with Merc ‚Äî the lead will randomly choose all three books with the slot machine.</div>
              <div class="wait-sub">We'll let you know when voting starts.</div>
              <div class="spinner" aria-hidden="true"></div>
            </div>`;
          if (container) container.innerHTML = dogHtml;
          else if(pollOptions) pollOptions.innerHTML = dogHtml;
          return;
        }
        const html = '<div class="text-muted small">'+msg+'<\/div>';
        if (container) container.innerHTML = html;
        else if(pollOptions) pollOptions.innerHTML = html;
      }

      // Try slotMachineState first
      const raw = localStorage.getItem('slotMachineState');
      let chosenIdxs = null;
      if (raw) {
        try {
          const st = JSON.parse(raw);
          if (Array.isArray(st.chosenIdxs)) chosenIdxs = st.chosenIdxs.slice(0,3);
        } catch(e){}
      }

      // Read manual winners from localStorage (if present) and normalize to {book,name}
      const rawManual = JSON.parse(localStorage.getItem('winners') || 'null');
      let manualChoices = Array.isArray(rawManual) ? rawManual.map(w => {
        // accept different shapes: {title,suggestedBy} or {book,name}
        const book = (w && (w.title || w.book || w[0])) || '';
        const name = (w && (w.suggestedBy || w.name || w[1])) || '';
        return { book: String(book).trim() || '(Unknown)', name: String(name).trim() || '' };
      }).filter(x=>x && x.book) : [];

      // If there are no slot choices AND no manual choices, show waiting message
      if ((!chosenIdxs || chosenIdxs.every(v=>v===null || v===undefined)) && manualChoices.length === 0){
        showMessage('Wait until the lead has randomly chosen all three books with the slot machine.');
        return;
      }

      // If manual choices alone satisfy the poll and all have 'name', use them immediately
      const needsName = (arr) => arr.some(x=>!x.name || !String(x.name).trim());
      if (manualChoices.length >= 3 && (!chosenIdxs || chosenIdxs.every(v=>v===null || v===undefined))) {
        const finalManual = manualChoices.slice(0,3);
        // If none are missing names, render fast-path
        if(!needsName(finalManual)){
          pollChoices = finalManual.map(i=>({ book: i.book, name: i.name||'' }));
          try{ persistPollChoices(pollChoices); }catch(e){}
          if(!pollVisible){ try{ showPollChoicesAnimated(); }catch(e){ if (typeof loadPollChoices === 'function') loadPollChoices(); } pollVisible = true; }
          if (typeof window.renderPollOptions === 'function') window.renderPollOptions();
          return;
        }
        // Otherwise fall through to fetch CSV so we can fill missing 'Suggested by' from submissions
      }

      // fetch CSV and map indices -> book/name
      try {
        const res = await fetch(CSV_URL);
        const csv = await res.text();
        const rows = csv.split('\n').slice(1); // skip header
        // helper to normalize book titles for matching
        const norm = s => String(s || '').toLowerCase()
          .replace(/["'‚Äô‚Äú‚Äù\(\)\[\]\.\,;:\-‚Äî\/]/g,'') // remove punctuation incl. hyphen and em-dash and slashes
          .replace(/\s+/g,' ').trim();
        // parse any CSV line into {display,title,name}
        function parseLineToPair(line){
          const cols = (function(line){
            const out = []; let cur=''; let inQ=false;
            for(let i=0;i<line.length;i++){
              const ch=line[i];
              if(ch==='"'){
                if(inQ && line[i+1]==='"'){ cur+='"'; i++; }
                else inQ = !inQ;
              } else if(ch===',' && !inQ){ out.push(cur); cur=''; }
              else cur+=ch;
            }
            out.push(cur);
            return out;
          })(line);
          // Column heuristic: title is usually in cols[1]; suggester (who suggested the book) in cols[2]
          const rawTitle = (cols[1] || '').trim();
          const suggestedBy = (cols[2] || '').trim();
          // title-only (strip author) for matching
          let titleOnly = rawTitle;
          const dashRe = /\s*-\s*/;
          if(dashRe.test(rawTitle)){
            const parts = rawTitle.split(dashRe);
            titleOnly = parts.slice(0,1).join('-').trim();
          } else {
            const byMatch = rawTitle.match(/\s+by\s+/i);
            if(byMatch){
              const parts = rawTitle.split(/\s+by\s+/i);
              titleOnly = parts[0].trim();
            }
          }
          return { display: rawTitle || '', title: titleOnly || '', name: suggestedBy || '' };
        }
        // Build a lookup from normalized book -> suggestedBy (first match wins)
        const bookToName = {};
        for(let i=0;i<rows.length;i++){
          const raw = rows[i]||'';
          if(!raw.trim()) continue;
          const p = parseLineToPair(raw);
          const k = norm(p.title);
          if(k && !bookToName[k]) bookToName[k] = p.name || '';
        }
        // Build poll choices from chosen indices (slot-derived) using parseLineToPair for consistency
        const slotChoices = [];
        if (Array.isArray(chosenIdxs)) chosenIdxs.forEach((origIdx) => {
          if (origIdx === null || origIdx === undefined) return;
            const row = rows[origIdx] || '';
            const p = parseLineToPair(row);
            slotChoices.push({ book: p.display || p.title || 'Unknown book', title: p.title || '', name: p.name || '' });
        });

        // Merge manualChoices (preferred) with slotChoices to form finalChoices
  const final = [];
  const seen = new Set();
  // Add manual first (if any) using normalized title-only keys
  for(const m of manualChoices){ if(final.length>=3) break; const titleOnly = (function(b){ const parts = String(b||'').split(/\s-\s/); return parts[0]||b||''; })(m.book); const key = norm(titleOnly); if(!seen.has(key)){ final.push({ book: m.book, title: titleOnly, name: m.suggestedBy||m.name||'' }); seen.add(key); } }
  // Fill from slot choices keeping order and avoiding duplicates
  for(const s of slotChoices){ if(final.length>=3) break; const key = norm(s.title||s.book||''); if(!seen.has(key)){ final.push({ book: s.book, title: s.title||s.book, name: s.name||'' }); seen.add(key); } }

        // Fill missing suggestedBy from the CSV lookup using title-only keys
        final.forEach(item => {
          if(!item.name || !String(item.name).trim()){
            const k = norm(item.title || item.book);
            if(k && bookToName[k]) item.name = bookToName[k];
          }
        });

        if (final.length === 3) {
          // Ensure pollChoices are {book, name} (display book and suggestedBy)
          pollChoices = final.map(i=>({ book: i.book, name: i.name||'' }));
          try{ persistPollChoices(pollChoices); }catch(e){}
          // Only reset votes if the slot machine was explicitly Reset
          try{
            if(localStorage.getItem('slotMachineReset')){
              localStorage.removeItem('votes'); votes = {};
              localStorage.removeItem('slotMachineReset'); // consume the flag
            }
          }catch(e){}
          // animate render only once we have all three choices
          if(!pollVisible){
            try{ showPollChoicesAnimated(); }catch(e){ if (typeof loadPollChoices === 'function') loadPollChoices(); }
            pollVisible = true;
          } else {
            // already visible; just ensure UI is up-to-date
            if (typeof loadPollChoices === 'function') loadPollChoices();
          }
          // and notify the other render function if present
          if (typeof window.renderPollOptions === 'function') window.renderPollOptions();
        } else {
          // not ready yet - ensure pollVisible is false so animation can run later
          pollVisible = false;
          showMessage('Wait until the lead has randomly chosen all three books with the slot machine.');
        }
      } catch (err) {
        console.error(err);
        showMessage('Failed to load book details.');
      }
    }

    // initial load
    loadWinnersAndChoices();

    // Poll localStorage periodically in case winners are written by another tab
    const POLL_INTERVAL_MS = 2000;
    const pollTimer = setInterval(() => {
      try{ loadWinnersAndChoices(); }catch(e){}
    }, POLL_INTERVAL_MS);

    // Also listen to storage events (cross-tab) and custom events from admin script
    window.addEventListener('storage', (ev)=>{
      if(!ev.key) return;
      try{
        if(ev.key==='winners' || ev.key==='slotMachineState' || ev.key==='pollChoices'){
          loadWinnersAndChoices();
          return;
        }
        if(ev.key==='votes'){
          // reload votes and refresh voter displays
          try{ votes = JSON.parse(localStorage.getItem('votes')) || {}; }catch(e){ votes = {}; }
          // update all voter divs and checkbox states
          (pollChoices||[]).forEach(c=> updateVoters(c.book));
          return;
        }
      }catch(e){ /* ignore */ }
    });

    // Custom events dispatched by admin page when winners are saved/cleared
    window.addEventListener('winnersSaved', (ev)=>{ try{ loadWinnersAndChoices(); }catch(e){} });
    window.addEventListener('winnersCleared', (ev)=>{ try{ pollOptions.innerHTML=''; showMessage('Wait until the lead has randomly chosen all three books with the slot machine.'); }catch(e){} });
  </script>
</body>
</html>