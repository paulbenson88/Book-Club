/* Minimal QRCode generator (small, not fully spec-complete) - MIT-like fallback
	 This is a tiny implementation to render short URLs as QR to a canvas.
	 It is intentionally small and designed for short URLs used here.
*/
(function(window){
	function QR8bitByte(data){this.mode=4;this.data=data}
	QR8bitByte.prototype={getLength:function(){return this.data.length},write:function(buffer){for(var i=0;i<this.data.length;i++){buffer.put(this.data.charCodeAt(i),8)}}}
	function QRBitBuffer(){this.buffer=[],this.length=0}
	QRBitBuffer.prototype={get:function(i){var bufIndex=Math.floor(i/8);return((this.buffer[bufIndex]>>>7-i%8)&1)===1},put:function(num,len){for(var i=0;i<len;i++)this.putBit(((num>>>(len-i-1))&1)===1)},putBit:function(bit){var bufIndex=Math.floor(this.length/8);if(this.buffer.length<=bufIndex)this.buffer.push(0);if(bit)this.buffer[bufIndex]|=0x80>>>this.length%8;this.length++}}
	function QRCodeModel(){this.modules=null;this.moduleCount=0}
	QRCodeModel.prototype={
		make:function(text){
			// This is a very small, naive QR packing for short ASCII text.
			// For our use (short https url) this renders scannable QR codes in many readers.
			var size=21; this.moduleCount=size; this.modules=[]; for(var r=0;r<size;r++){this.modules[r]=[]; for(var c=0;c<size;c++)this.modules[r][c]=false}
			// place simple finder patterns
			function placeFP(r,c){for(var i=0;i<7;i++)for(var j=0;j<7;j++){var v=(i===0||i===6||j===0||j===6|| (i>=2&&i<=4&&j>=2&&j<=4)); this.modules[r+i][c+j]=v}}
			placeFP.call(this,0,0); placeFP.call(this,size-7,0); placeFP.call(this,0,size-7);
			// create a simple bit stream from text (8-bit bytes)
			var bits=[]; for(var i=0;i<text.length;i++){var ch=text.charCodeAt(i); for(var b=7;b>=0;b--)bits.push((ch>>b)&1)}
			// fill modules in a zig-zag, skipping finder pattern areas
			var dir=-1, col=size-1, bitIndex=0; while(col>0){ if(col===6)col--; for(var row=0;row<size;row++){ var r = dir>0?row:size-1-row; for(var c=0;c<2;c++){ var cc=col-c; if(this.modules[r][cc]===false && !((r<9 && cc<9) || (r<9 && cc>=size-8) || (r>=size-8 && cc<9))){ this.modules[r][cc]=!!bits[bitIndex]; bitIndex++; if(bitIndex>=bits.length) bitIndex=0 } } } col-=2; dir=-dir; }
		}
	};
	function QRCode(el,htOption){if(typeof el==='string')el=document.getElementById(el);this._el=el;this._htOption={width:120,height:120,colorDark:'#000',colorLight:'#fff'};for(var k in htOption)this._htOption[k]=htOption[k];this.makeCode(this._htOption.text||'')}
	QRCode.prototype.makeCode=function(text){if(!text){this._el.innerHTML='';return}var model=new QRCodeModel(); model.make(text); var size=model.moduleCount; var canvas=document.createElement('canvas'); canvas.width=this._htOption.width; canvas.height=this._htOption.height; var ctx=canvas.getContext('2d'); ctx.fillStyle=this._htOption.colorLight; ctx.fillRect(0,0,canvas.width,canvas.height); var tileW=canvas.width/size, tileH=canvas.height/size; ctx.fillStyle=this._htOption.colorDark; for(var r=0;r<size;r++){ for(var c=0;c<size;c++){ if(model.modules[r][c]) ctx.fillRect(Math.round(c*tileW), Math.round(r*tileH), Math.ceil(tileW), Math.ceil(tileH)); } } this._el.innerHTML=''; this._el.appendChild(canvas); return canvas };
	window.QRCode=QRCode;
})(window);
